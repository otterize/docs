---
sidebar_position: 5
title: Deploy mTLS between pods
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Otterize can automatically provision mTLS credentials by using the service identities implied by Kubernetes.
This tutorial will walk you through deploying mTLS certificates on a sample client-server deployment using the [Otterize SPIRE integration operator](concepts/otterize-oss/componentsspire-integration-operator), which works with a [SPIRE server](https://spiffe.io/docs/latest/spire-about/) to achieve this.

In this tutorial, we will:

- Deploy client and server pods communicating over HTTP with mTLS.
- See that mTLS credentials were autogenerated.


<details>
<summary>Install Otterize on your cluster</summary>

:::note
You can skip this section if Otterize is already installed in your cluster.
:::

{@include: ../_common/install-otterize.md}

</details>


## Deploy the example

Our example consists of two pods, "client" and "server", communicating over HTTP with mTLS.
Otterize makes mTLS easy, requiring just 3 simple changes to a client pod spec:
1. **Generate credentials**: add the `otterize/tls-secret-name` annotation, which tells the Otterize
   SPIRE integration operator to generate mTLS credentials, and to store them in a Kubernetes secret
   whose name is the value of this annotation.
2. **Expose credentials in a volume**: add a volume containing this secret to the pod.
3. **Mount the volume**: mount the volume in every container in the pod.

<details>
<summary>Expand to see this structure</summary>

```yaml
spec:
  template:
    metadata:
      annotations:
        # highlight-next-line
        # 1. Generate credentials as a secret called "client-credentials-secret":
        otterize/tls-secret-name: client-credentials-secret
        ...
    spec:
      volumes:
        # highlight-start
        # 2. Create a volume containing this secret:
        - name: otterize-credentials
          secret:
            secretName: client-credentials-secret
        # highlight-end
        ...
      containers:
        - name: client
          ...
          volumeMounts:
            # highlight-start
            # 3. Mount volume into container
            - name: otterize-credentials
              mountPath: /var/otterize/credentials
              readOnly: true
            # highlight-end
```
</details>

<details>
<summary>Expand to see the complete YAML files of the example</summary>
<Tabs>

<TabItem value="namespace.yaml" label="namespace.yaml" default>

```yaml
{@include: ../../static/code-examples/kafka-mtls/namespace.yaml}
```

</TabItem>

<TabItem value="client-deployment.yaml" label="client-deployment.yaml">

```yaml
{@include: ../../static/code-examples/kafka-mtls/client-deployment.yaml}
```

</TabItem>

<TabItem value="client-configmap.yaml" label="client-configmap.yaml">

```yaml
{@include: ../../static/code-examples/kafka-mtls/client-configmap.yaml}
```

</TabItem>
<TabItem value="client.js" label="client.js" default>

```js
const fs = require('fs');
const https = require('https');

const options = {
    hostname: 'server.otterize-tutorial-mtls',
    port: 443,
    path: '/hello',
    method: 'GET',
    cert: fs.readFileSync('/var/otterize/credentials/svid.pem'),
    key: fs.readFileSync('/var/otterize/credentials/key.pem'),
    ca: fs.readFileSync('/var/otterize/credentials/bundle.pem')
}

const req = https.request(
    options,
    res => {
        res.on('data', function (data) {
            console.log(data.toString())
        });
    }
);

req.end();
```

</TabItem>
<TabItem value="server.js" label="server.js" default>

```js
const https = require(`https`);
const fs = require(`fs`);

const options = {
  key: fs.readFileSync('/var/otterize/credentials/key.pem'),
  cert: fs.readFileSync('/var/otterize/credentials/svid.pem'),
  ca: fs.readFileSync('/var/otterize/credentials/bundle.pem'),
  requestCert: true
};

https.createServer(
    options,
    (req, res) => {
        const peerCert = req.connection.getPeerCertificate();
        const ownCert = req.connection.getCertificate();
        console.log("Received request:");
        console.log(peerCert.subject.CN + ":\t" + req.method + " " + req.url);
        if (req.url === '/hello') {
            res.writeHead(200);
            res.end('mTLS hello world\nfrom: ' + ownCert.subject.CN + '\nto client: ' + peerCert.subject.CN);
        } else {
            res.end();
        }
    }).listen(443);
```

</TabItem>
</Tabs>
</details>

Deploy the client and server using `kubectl`:
```bash
kubectl apply -f https://docs.otterize.com/code-examples/mtls/all.yaml
```

<details>
<summary>Optional: check deployment status</summary>

```bash
kubectl get pods -n otterize-tutorial-mtls
```
You should see
```
NAME                      READY   STATUS    RESTARTS   AGE
client-5689997b5c-grlnt   1/1     Running   0          35s
server-6698c58cbc-v9n9b   1/1     Running   0          34s
```
</details>

## Watch it in action

1. Confirm that the client can successfully call the server using HTTP with mTLS:

   ```bash
   kubectl logs --tail 3 -n otterize-tutorial-mtls deploy/client
   ```

   The client makes requests and prints out the server's response; our example server will respond with
   the `common name` of the server's certificate as well as the `common name` of the client's certificate:

   ```shell
   mTLS hello world
   from: server.otterize-tutorial-mtls          # server's common name in the certificate
   to client: client.otterize-tutorial-mtls     # client's common name in the certificate
   ```
2. You can also confirm on the server side that it sees requests from this authenticated client:
   ```bash
   kubectl logs --tail 1 -n otterize-tutorial-mtls deploy/server
   ```

   The example server logs the common name of every client that makes a request:

   ```shell
   client.otterize-tutorial-mtls:  GET /hello
   ```

:::info Certificate lifecycle management
Otterize leverages SPIRE to manage certificate lifecycle management tasks such as rotation, revocation, etc.

We recommend reloading credentials before each use, as Otterize makes sure
the mounted credentials are constantly refreshed and up to date.
:::

## Inspect credentials

We can use `openssl` to inspect the generated credentials. The credentials are stored as a Kubernetes secret
and are then mounted as a file into the container.

1. Retrieve the credentials from the Kubernetes secret:

   ```shell
   kubectl get secret -n otterize-tutorial-mtls client-credentials-secret -o jsonpath='{.data.svid\.pem}' | base64 -d > svid.pem
   ```

2. Inspect the credentials with `openssl`:

   ```shell
   openssl x509 -in svid.pem -text | head -n 15
   ```
   You should see output similar to:
   ```x509
   Certificate:
       Data:
           Version: 3 (0x2)
           Serial Number:
               0b:eb:eb:4d:0e:02:7e:28:93:30:1c:55:26:22:8b:c7
           Signature Algorithm: sha256WithRSAEncryption
           Issuer: C = US, O = SPIRE
           Validity
               Not Before: Aug 24 12:19:57 2022 GMT
               Not After : Sep 23 12:20:07 2022 GMT
   # highlight-next-line
           Subject: C = US, O = SPIRE, CN = client.otterize-tutorial-mtls       # the client's name
           Subject Public Key Info:
               Public Key Algorithm: id-ecPublicKey
                   Public-Key: (256 bit)
                   pub:
   ```

3. You can see that Otterize generated an X.509 keypair using the pod's name ("client")
   and namespace ("otterize-tutorial-mtls"): `client.otterize-tutorial-mtls`.
   The certificate belongs to a chain of trust rooted at the SPIRE server.

<details>
<summary>Expand to see what happened behind the scenes</summary>

1. We annotated the pods to let Otterize know it should generate mTLS credentials.
2. The Otterize SPIRE integration operator:
    1. Created entries in the SPIRE server for the annotated pods.
    2. Generated matching mTLS credentials using the SPIRE server.
    3. Stored the mTLS credentials into Kubernetes secrets.
3. The secrets were mounted (separately) into each pod's container.
4. The pods communicated with each other using mutual TLS-authenticated HTTPS.

</details>

:::tip
Otterize defaults to generating credentials with an expiry time of 1 day. The certificates are
automatically refreshed before expiring, and therefore you must always read the credentials from file rather than caching them.

To set a longer expiration time, set the `spire-integration.otterize.com/cert-ttl` annotation for your pods.
For more information, see [the documentation for the SPIRE integration operator](concepts/otterize-oss/componentsspire-integration-operator)
:::

## What's next

- Learn how to manage and [automatically provision mTLS](/k8s-mtls) credentials within a Kubernetes cluster.
- Read about how to [integrate](/k8s-mtls/#using-mtls-credentials) mTLS into common SDKs and frameworks.
- Enforce [secure Kafka access](/k8s-kafka-mtls) with mTLS.
- Learn more about how the [Otterize SPIRE integration operator](concepts/otterize-oss/componentsspire-integration-operator) works.

## Teardown

To remove the deployed examples run:

```bash
kubectl delete -f https://docs.otterize.com/code-examples/mtls/all.yaml
```
