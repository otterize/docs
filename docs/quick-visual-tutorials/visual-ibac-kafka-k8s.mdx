---
sidebar_position: 3
title: "Visual tutorial: IBAC for Kafka in Kubernetes"
sidebar_label: "IBAC for Kafka in Kubernetes"
---

import CodeBlock from "@theme/CodeBlock";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

This tutorial focuses on intent-based access control (IBAC) for Kafka, specifically for a Kafka broker and its clients running within a Kubernetes cluster.

Otterize OSS configures access controls automatically, based on declared and applied *client* intents, as we'll now see.
- In the [previous tutorial](/quick-visual-tutorials/visual-ibac-network-policies), we rolled out IBAC by declaring intents for pods to call each other. Otterize OSS automatically configured Kubernetes network policies to enable access based on those intents and block any undeclared access.
- In this tutorial, we add fine-grained, topic- and operation-level intents to the existing pod-to-pod intents. Otterize OSS automatically configures Kafka ACLs, and issues and distributes certificates to Kafka clients, so they can authenticate via mTLS and perform those operations on those topics, while everything undeclared is blocked.
- Otterize Cloud again enriches these capabilities with a visual access graph, displaying a unified view of topic- and operation-level access and protection, and client identity certificate information.
- Otterize Cloud also provides a pre-configured certificate credentials service you may use instead of running one (e.g. SPIRE) in your cluster.

:::info
While this tutorial build on the network policies IBAC tutorial, you need not use or even be concerned with network policies to achieve IBAC for Kafka with Otterize. Since all the network policies needed to run the demo below are already in place, we start this tutorial with all the access needed for the demo to run &mdash; much as it would if we weren't using network policies at all.
:::

In this tutorial, we will:

- Start where the previous tutorial left off: with a demo based on the [Google microservices demo](https://github.com/GoogleCloudPlatform/microservices-demo)
(a simple e-commerce application) deployed to a Kubernetes cluster, with Otterize OSS installed and integrated with Otterize Cloud.
- We will add fine-grained, topic-level intents and see how access to operations on Kafka topics is automatically managed.

## Prerequisites
The following steps are only needed if you haven't already run through the [Kubernetes cluster mapping tutorial](/quick-visual-tutorials/visual-k8s-cluster-mapping).

<details>
<summary>Prepare a cluster</summary>

Before you start, you'll need a Kubernetes cluster.

You won't need [network policies](https://kubernetes.io/docs/concepts/services-networking/network-policies/) in this tutorial,
so you can follow the steps below while skipping the network policies (CNI) enablement bits, or keep them as is.

{@include: ../_common/cluster-setup.md}
</details>

<details>
<summary>Deploy the demo set of services</summary>

To deploy these into your cluster:
```bash
kubectl create namespace otterize-ecom-demo
kubectl apply -n otterize-ecom-demo -f https://docs.otterize.com/code-examples/shadow-mode/ecom-demo.yaml
```

</details>

<details>
<summary>Create an Otterize Cloud account</summary>

If you don't already have an account, browse to [https://app.otterize.com](https://app.otterize.com) to set one up.

If someone in your team has already created an org in Otterize Cloud, and invited you (using your email address), you may see an invitation to accept.

Otherwise, you'll create a new org, which you can later rename, and invite your team mates to join you there.
</details>

<details>
<summary>Install Otterize OSS</summary>

If no Kubernetes clusters are connected to your account, click the "connect your cluster" button to:
1. Create a Cloud cluster object, specifying its name and the name of an environment to which all namespaces in that cluster will belong, by default.
2. Connect it with your actual Kubernetes cluster, by clicking on the "Connection guide &rarr;" link and running the Helm commands shown there.
   1. The Helm command shown in the Cloud UI also includes flags to turn off enforcement, but you'll want to omit those and run Otterize with enforcement turned on, for this tutorial.

:::tip More details, if you're curious

Connecting your cluster simply entails installing Otterize OSS via Helm, using credentials from your account so Otterize OSS can report information needed to visualize the cluster.

The credentials will already be inlined into the Helm command shown in the Cloud UI, so you just need to copy that line and run it from your shell.
If you don't give it the Cloud credentials, Otterize OSS will run fully standalone in your cluster &mdash; you just won't have the visualization in Otterize Cloud.
:::
</details>

<details>
<summary>Apply pod-to-pod-level intents</summary>

This tutorial picks up where the network policies tutorial left off. We'll want to make sure all the pods have access to the pods they'll need to call,
so we'll put in place the same intents that we had in that tutorial. There, we showed how you can bootstrap all those intents, by observing the calls the pods are making using the network mapper, and then exporting the network map as a set of intents files.

```bash
kubectl apply -n otterize-ecom-kafka-demo -f https://docs.otterize.com/code-examples/shadow-mode/all.yaml
```

</details>

<details>
<summary>Optional: check that the demo was deployed...</summary>

To see all the pods in the demo:
```bash
kubectl get pods -n otterize-ecom-demo
```
The pods should all be ready and running:
```bash
NAME                                     READY   STATUS    RESTARTS      AGE
adservice-65494cbb9d-5lrv6               1/1     Running   0             115s
cartservice-6d84fc45bb-hdtwn             1/1     Running   0             115s
checkoutservice-5599486df-dvj9n          1/1     Running   3 (79s ago)   115s
currencyservice-6d64686d74-lxb7x         1/1     Running   0             115s
emailservice-7c6cbfbbd7-xjxlt            1/1     Running   0             115s
frontend-f9448d7d4-6dmnr                 1/1     Running   0             115s
kafka-0                                  1/1     Running   2 (83s ago)   115s
loadgenerator-7f6987f59-bchgm            1/1     Running   0             114s
orderservice-7ffdbf6df-wzzfd             1/1     Running   0             115s
otterize-ecom-demo-zookeeper-0           1/1     Running   0             115s
paymentservice-86855d78db-zjjfn          1/1     Running   0             115s
productcatalogservice-5944c7f666-2rjc6   1/1     Running   0             115s
recommendationservice-6c8d848498-zm2rm   1/1     Running   0             114s
redis-cart-6b79c5b497-xpms2              1/1     Running   0             115s
shippingservice-85694cb9bd-v54xp         1/1     Running   0             114s
```

</details>

<details>
<summary>Optional: Browse the demo</summary>
<Tabs groupId="frontend-addr">
<TabItem value="k8s" label="K8s">

To get the externally-accessible URL where your demo front end is available, run:
```bash
kubectl get service -n otterize-ecom-demo frontend-external | awk '{print $4}'
```
The result should be similar to (if running on AWS EKS):
```
a11843075fd254f8099a986467098647-1889474685.us-east-1.elb.amazonaws.com
```
Go ahead and browse to the URL above to "shop" and get a feel for the demo's behavior.
(The URL might take some time to populate across DNS servers. Note that we are accessing an HTTP and not an HTTPS website.)
</TabItem>
<TabItem value="minikube" label="Minikube">

To get the externally-accessible URL where your demo front end is available, run:
```
kubectl port-forward -n otterize-ecom-demo service/frontend-external 8080:80 &
```
The demo is now accessible at:
```
http://localhost:8080
```
Go ahead and browse to the URL above to "shop" and get a feel for the demo's behavior.
</TabItem>
</Tabs>
</details>

## Seeing the access graph.

In the Otterize Cloud UI, the [access graph](https://app.otterize.com/access-graph) should show the following map for the demo running in your cluster:
<img src="/img/quick-tutorials/shadow-mode/phase-5.png" alt="Discovered intents" width="600"/>

Notice that Kafka is shown just like any other service that's called by (in this case, 4) other services acting as its clients. We'll let Otterize know this is a Kafka-type service in the next step.

## Manage Kafka access with Otterize

Let's configure Otterize to recognize Kafka and communicate with it by applying a `KafkaServerConfig`:
```bash
kubectl apply -n otterize-ecom-kafka-demo -f https://docs.otterize.com/code-examples/shadow-mode/kafkaserverconfig.yaml
```
<details>
<summary>Expand to see the KafkaServerConfig</summary>
<Tabs>

<TabItem value="kafkaserverconfig.yaml" label="kafkaserverconfig.yaml">

```yaml
{@include: ../..//static/code-examples/shadow-mode/kafkaserverconfig.yaml}
```

</TabItem>
</Tabs>
</details>

Upon applying the KafkaServerConfig, an ACL will configure Kafka to allow anonymous access all topics.
This will be the base state, from which we will gradually roll out secure access to Kafka.

We can see in the access graph that the node is marked with a `Kafka` and `KSC` icons.

![Kafka Server Config](/img/quick-tutorials/shadow-mode/kafka-node.png)

By clicking the Kafka node twice and switching to focus mode we'll be able to inspect its configuration and credentials.

![Kafka Server Config](/img/quick-tutorials/shadow-mode/kafka-focus.png)


## Declare Kafka intents

Otterize can now configure Kafka ACLs so let's go ahead and create client intents files for the services communicating with Kafka.

<Tabs>
<TabItem value="checkoutservice" label="checkoutservice" default>

```yaml
{@include: ../..//static/code-examples/shadow-mode/phase-4-checkout.yaml}
```
</TabItem>
<TabItem value="orderservice" label="orderservice" default>

```yaml
{@include: ../..//static/code-examples/shadow-mode/phase-4-order.yaml}
```
</TabItem>
<TabItem value="paymentservice" label="paymentservice" default>

```yaml
{@include: ../..//static/code-examples/shadow-mode/phase-4-payment.yaml}
```
</TabItem>
</Tabs>

And apply them with

```bash
kubectl apply -n otterize-ecom-kafka-demo -f https://docs.otterize.com/code-examples/shadow-mode/kafka-intents.yaml
```

We can immediatly see that the relevant edges are marked with the Kafka icon.

![Kafka Server Config](/img/quick-tutorials/shadow-mode/kafka-edges.png)

And by clicking each of these edge we are able to see the specific topics declared by the client workload for access.

![Kafka Server Config](/img/quick-tutorials/shadow-mode/kafka-edge-modal.png)

:::note
You can verify that the reference lab still functions as intended.
:::

## What's next

* [Rollout mTLS](/quick-tutorials/k8s-mtls) between your workloads.
* [Deploy a dedicated Kafka broker and take it for a spin using intents](/quick-tutorials/k8s-kafka-mtls).

## Teardown

To remove the deployed lab delete the client intents:
```bash
kubectl delete -n otterize-ecom-kafka-demo -f https://docs.otterize.com/code-examples/shadow-mode/all.yaml
```

Then remove the Kafka Server Config:
```bash
kubectl delete -n otterize-ecom-kafka-demo -f https://docs.otterize.com/code-examples/shadow-mode/kafkaserverconfig.yaml
```
And then remove the lab and the namespace:
```bash
kubectl delete -n otterize-ecom-kafka-demo -f https://docs.otterize.com/code-examples/shadow-mode/ecom-demo-mtls.yaml
kubectl delete namespace otterize-ecom-kafka-demo
```