---
sidebar_position: 4
title: "Visual tutorial: IBAC with Istio authorization policies"
sidebar_label: "IBAC with Istio authorization policies"
---

import CodeBlock from "@theme/CodeBlock";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Istio authorization policies are a powerful and flexible tool, but using them to achieve a zero-trust architecture with fine-grained pod-to-pod access control can be difficult to implement and maintain.

In this tutorial, we will show you how to roll out Istio authorization policies with intent-based access control (IBAC).
With IBAC, you won't need to manually keep track of pod labels or service accounts. You won't need to manage Istio authorization policies at all &mdash; they'll be generated and managed automatically! We'll even show you how to generate policies for all discovered traffic in the cluster with just one command.

By the end of this tutorial, each server in the cluster will only allow the incoming calls declared by client services in their client intents files, and block any undeclared (unintentional) calls. Call declarations, and the authorization policies they'll generate, will specify not just the server but also the HTTP path and method.

All the capabilities of IBAC for Istio are within Otterize OSS, while the access graph in Otterize Cloud will guide us
visually in these steps and support us in the process of zero trust adoption in our cluster without breaking anything.

You will:
1. Install Otterize OSS in your Kubernetes cluster, integrated to your Otterize Cloud account.
2. View, within Otterize Cloud, the traffic in your cluster.
3. Declare one intent just to see how the generated authorization policies affect the cluster.
4. Generate client intents for all traffic in the cluster to achieve zero trust in one command.

## Prerequisites

<details>
<summary>Prepare a Kubernetes cluster</summary>

Before you start, you'll need a Kubernetes cluster. Having a cluster with a [CNI](https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/) that supports [NetworkPolicies](https://kubernetes.io/docs/concepts/services-networking/network-policies/) isn't required for this tutorial, but is recommended so that your cluster works with other tutorials.

{@include: ../_common/cluster-setup.md}
</details>

<details>
<summary>Create an Otterize Cloud account</summary>

{@include: ../_common/create-account.md}

</details>

<details>
<summary>Install Otterize OSS </summary>

{@include: ../_common/install-otterize-from-cloud.md}

</details>

<details>
<summary>Install the Otterize CLI</summary>

{@include: ../_common/install-otterize-cli.md}

</details>

## Install and configure Istio
<details>
<summary>Install Istio in the cluster via Helm</summary>

{@include: ../_common/install-istio.md}

</details>

<details>
<summary>Enhance Istio Exported Metrics with HTTP Methods and Request Paths</summary>

After successfully installing Istio, we can enrich Otterize Network Mapper with Envoy metrics information to
include HTTP resource access details in the network map. However, HTTP requests data isn't logged by default, so we
need to enable it ourselves.

Apply this configuration in the `istio-system` namespace, propagating it to all namespaces covered by the mesh.

```
kubectl apply -f https://docs.otterize.com/code-examples/network-mapper/istio-telemetry-enablement.yaml
```

```yaml
{@include: ../../static/code-examples/network-mapper/istio-telemetry-enablement.yaml}
```

</details>

:::tip
HTTP request paths and methods aren't exported in Envoy's connection metrics by default, but we do want to capture those
details when creating the network map. That way we not only have better visibility of the calling patterns,
e.g. in the access graph, but we can also use that information to automatically capture fine-grained intents and
use them to generate Istio authorization policies.
:::

## Deploy demo to simulate traffic
<details>
<summary>Create a namespace for our demo application and label it for Istio injection</summary>

```bash
kubectl create namespace otterize-visual-tutorial-istio
kubectl label namespace otterize-visual-tutorial-istio istio-injection=enabled
```
</details>

<details>
<summary>Deploy the demo set of services</summary>

```
kubectl apply -n otterize-visual-tutorial-istio -f https://docs.otterize.com/code-examples/ibac-for-istio/demo-app.yaml
```
</details>

## Seeing the access graph

In the Clusters table at Otterize Cloud UI, your [cluster](https://app.otterize.com/clusters) should be displaying all three Otterize OSS
operators &mdash; the intents operator, network mapper, and credentials operator. They should all be in connected state, indicated by a green dot.

![Access graph](/img/quick-tutorials/istio-visual-tutorial/cluster-connected.png)

Now, let's head back to the [access graph](https://app.otterize.com/access-graph). If necessary, make sure to select your cluster from the dropdown menu.
You should see the map for the demo running in your cluster:

![Access graph](/img/quick-tutorials/istio-visual-tutorial/phase-0.png)

Each service is shown as a node in the access graph, while the dashed lines (edges) connecting the services show access between them, as detected by the network mapper.

The lines are dashed because the client services are missing intent declarations: we've discovered their intents to call the servers, but they haven't declared those intents.

Otterize can manage few enforcement mechanisms, but not every cluster will have all of them. Each view take into account
its relevant implementation details and weather communication is enabled by default or not.
In this case, we are using Istio authorization policies, so we need to adjust the access graph view to take into account
Istio authorization policies, so turn on the Istio policies "Use in access graph" toggle and turn off the network
policies and Kafka ACLs toggle buttons.

![Access graph](/img/quick-tutorials/istio-visual-tutorial/access-graph-panel.png)

## Try out IBAC with shadow mode

Our mission in this tutorial is to achieve zero trust in our cluster, but we don't want to break anything in the process.
One of the biggest challenges in doing so is that Istio authorization policies, like network policies and Kafka ACLs, doesn't
have the ability to let us know what would be blocked *before* we actually block it.

Otterize solves this problem by providing a Shadow mode enforcement. In shadow mode, Otterize doesn't actually generate
access controls (in this case, Istio authorization policies) from client intents declarations. Nothing is actually blocked
and the access graph will help us understand what would happen if we were to enable enforcement.

## Choose a first service to protect

There are many services in the demo, but we will pick one and manually protect it before we will automate the process
for the whole cluster. We will start with the `recommendationservice` service, so first find it in the graph, you can
type its name in the search box and select it, the graph will zoom in on it:

![Access graph](/img/quick-tutorials/istio-visual-tutorial/recommendation-graph-phase-0.png)

Now, click on the `recommendationservice` service to see the details panel:

![Access graph](/img/quick-tutorials/istio-visual-tutorial/recommendation-service-phase-0.png)

On the left panel the state of this service as a server is presented. You can see that this service is unprotected, but
since there are no intents declared for it, it won't block any access even if we enable enforcement - as long as there is
no default `allow nothing` authorization policy in the cluster. On the right panel, the state of this service as a client
is presented, it's not expected to be blocked by any authorization policy either.

At the bottom part of panel we can see that this service is called by the `frontend`
service and uses the `GET` method to access the `/recommendations` resource. Let's click the dashed line from `frontend`
to `recommendationservice` to see the details of the access:

![Access graph](/img/quick-tutorials/istio-visual-tutorial/frontend-recommendation-phase-0.png)

On the left there is a discovered intent for those two services, but it is not declared.

## Make it intentional!

Now we will take the intent we just discovered and make intentional by declaring that the `frontend` service intends to
call the `recommendationservice` by sending `GET` requests to the HTTP resource at `/recommendations`:

```yaml
{@include: ../../static/code-examples/ibac-for-istio/phase-1.yaml}
```

We expect this will provide secure access, allowing the intended access from the `frontend` while protecting the `recommendationservice` from unintended access.

Apply the above client intents file with:
```bash
kubectl apply -n otterize-visual-tutorial-istio -f https://docs.otterize.com/code-examples/ibac-for-istio/phase-1.yaml
```

Look at the access graph again:

![Access graph](/img/quick-tutorials/istio-visual-tutorial/phase-1.png)

The green line from `frontend` to `recommendationservice`, representing the discovered intent from the network mapper, is no longer dashed, but rather **solid**: the access we discovered was needed has now been declared.

Click on that `frontend` &rarr; `recommendationservice` line:
<img src="/img/quick-tutorials/istio-visual-tutorial/frontend-recommendation-applied.png" alt="Discovered intents" width="600"/>

- We can see the `frontend` calls the `recommendationservice`, and has declared that intent, so it will be guaranteed access even once enforcement is turned on.

Click on the `recommendationservice` itself:
<img src="/img/quick-tutorials/istio-visual-tutorial/recommendation-access-state.png" alt="Discovered intents" width="600"/>

Few more notes:

- We can see this service is not currently protected: after all, we're in shadow mode, and there are no authorization policies blocking unintended access.
- Small lock icon with the tag "Istio policies" indicates that this service is protected by Istio authorization policies, once we'll enable enforcement, of course.
- We can also see it would not block any clients once protection is enabled.
- And there is no warning about it remaining unprotected once enforcement is turned on. We have **a green light**, at least as far as this service goes, **for turning on enforcement** and protecting this service from any unintended calls.

### Declare more intents
We can see in the access graph that the `recommendationservice` in turn calls the `productcatalogservice`, sending `GET` requests to the resource at `/similar-products`, so let's declare that intent:

```yaml
{@include: ../../static/code-examples/ibac-for-istio/phase-2.yaml}
```

Apply this intents file with:
```bash
kubectl apply -n otterize-visual-tutorial-istio -f https://docs.otterize.com/code-examples/istio-visual-tutorial/phase-2.yaml
```
Look at the access graph again:

![Access graph](/img/quick-tutorials/istio-visual-tutorial/phase-2.png)

As before, the line from `recommendationservice` &rarr; `productcatalogservice` is now solid green line, with no warnings. That's what we expected when we properly declare a discovered intent.

But two other lines, `frontend` &rarr; `productcatalogservice` and `checkoutservice` &rarr; `productcatalogservice`, have turned orange. And a red warning has shown up on the `productcatalogservice`. Why?

Click on one of those orange lines:
<img src="/img/quick-tutorials/istio-visual-tutorial/frontend-productactalogservice-missing-intent.png" alt="Discovered intents" width="600"/>

- There is no declaration of the discovered `GET` calls from the `frontend` to the `productcatalogservice` at `/products`.
- This undeclared access is not blocked *now* &mdash; because we're still in shadow mode (otherwise the line would have been red).
- But access *would* be blocked once enforcement is turned on. To prevent that, we're told to declare the intent for this call.

Click on the `productcatalogservice`:
<img src="/img/quick-tutorials/istio-visual-tutorial/productcatalog-would-block.png" alt="Discovered intents" width="600"/>

- We can see it's not protected now, again because we're in shadow mode.
- But we can also see it *would* block any clients once protection is enabled.
- And there is an explicit warning to apply the missing intents from all its clients before turning on enforcement.


Let's declare those intents from the `frontend` and `checkoutservice` clients.

<Tabs>
<TabItem value="frontend" label="frontend" default>

```yaml
{@include: ../../static/code-examples/ibac-for-istio/phase-3-frontend.yaml}
```
</TabItem>
<TabItem value="checkout-service" label="checkoutservice" default>

```yaml
{@include: ../../static/code-examples/ibac-for-istio/phase-3-checkout.yaml}
```
</TabItem>
</Tabs>

Apply these intents files with:
```bash
kubectl apply -n otterize-visual-tutorial-istio -f https://docs.otterize.com/code-examples/ibac-for-istio/phase-3.yaml
```

Let's go back to the access graph:

![Access graph](/img/quick-tutorials/istio-visual-tutorial/phase-3.png)

Click on the `productcatalogservice`:

![Access graph](/img/quick-tutorials/istio-visual-tutorial/productcatalog-service-all-green.png)

All is well again: the `productcatalogservice` will be protected, and its 3 declared clients will have access, after enforcement is turned on.
Each client's access is limited to the HTTP resource and method declared in its intents file.

:::tip We can now see how to roll out IBAC gradually:
1. Pick a service to protect.
2. Make sure all its clients declare their intents to call it.
3. When you're ready, and the access graph shows green solid arrows without warnings, turn on enforcement.

The access graph and shadow mode allow us to gain confidence by showing what would happen, highlighting any problems, and pointi ng to their fixes.
:::


### Protect everything easily
Since Otterize already knows the problems and their fixes, could we somehow automatically bootstrap this for the whole cluster and protect all services, without breaking any intended calls? Yes!

The network mapper keeps track of all attempted calls, after all: those are the discovered intents. If you are confident that all intended call patterns have been exercised while the network mapper was running (so it could capture them), and all the calls it saw are intended and appropriate, you can use that information to automatically generate intent declarations and apply them.

Let's use the [Otterize CLI](/reference/cli) to export all discovered intents as YAML declarations:
```bash
otterize network-mapper export -n otterize-visual-tutorial-istio --output-type dir --output intents
```

You can apply them using:
```bash
kubectl apply -f intents
```

Or, equivalently, just use the already-generated intents files included in this docs location:
```bash
kubectl apply -n otterize-visual-tutorial-istio -f https://docs.otterize.com/code-examples/ibac-for-istio/all.yaml
```

<details>
<summary>If you are curious, have a look at the intents files generated by this single command:</summary>

<Tabs>
<TabItem value="frontend" label="frontend" default>

```yaml
{@include: ../../static/code-examples/ibac-for-istio/intents/frontend.yaml}
```
</TabItem>
<TabItem value="checkout-service" label="checkoutservice" default>

```yaml
{@include: ../../static/code-examples/ibac-for-istio/intents/checkoutservice.yaml}
```
</TabItem>
<TabItem value="recommendation-service" label="recommendationservice" default>

```yaml
{@include: ../../static/code-examples/ibac-for-istio/intents/recommendationservice.yaml}
```
</TabItem>
<TabItem value="cart-service" label="cartservice" default>

```yaml
{@include: ../../static/code-examples/ibac-for-istio/intents/cartservice.yaml}
```
</TabItem>
<TabItem value="load-generator" label="loadgenerator" default>

```yaml
{@include: ../../static/code-examples/ibac-for-istio/intents/loadgenerator.yaml}
```
</TabItem>
</Tabs>
</details>

Look at the access graph again:

![Access graph](/img/quick-tutorials/istio-visual-tutorial/phase-4.png)

The graph confirms that all services would be protected, and no intended calls would be blocked, once we apply protection.

:::tip
In essence, in one shot, we've declared that all the traffic in the environment where the mapper was running is all the intended traffic: all these calls, and no other calls, should be allowed.
:::


## Enable enforcement
With the confidence we've gained, let's enable enforcement (via Istio authorization policies) by upgrading your Otterize installation to remove the `intentsOperator.operator.enableEnforcement=false` flag.

At the top of the access graph, click the **Configure cluster** button; or in the clusters page, click on the **Connection guide &rarr;** link for your cluster.

Then run the Helm commands shown there, and specifically follow the instructions to install Otterize <b>with enforcement on</b> (not in shadow mode). Namely, <b>omit</b> the following flag in the Helm command:

`--set intentsOperator.operator.enableEnforcement=false`

Let's look at the access graph again:

![Access graph](/img/quick-tutorials/shadow-mode/phase-5.png)

Note that all (but two) of the servers are shown in green, as protected. And no client call attempts (discovered by the network mapper) are being blocked. This is what a service-to-service zero-trust architecture looks like.

:::tip How would blocked access attempts look now?
From now on, if a client attempts a server call that wasn't covered by one of the declared intents, that would be discovered by the network mapper and show up as (new) discovered intents. Remember that the network mapper discovers attempted access, not just successful access. In this case, a red line would appear from that client to that server, and the lock on that server would turn red: calls from that client are being blocked.

That may be because:
- The calls were legitimate, but were missed when intents were generated because they didn't happen when the network mapper was building its map from which the intents were bootstrapped. In that case, you may choose to generate all the intents again, or or just create and apply the new ones manually.
- Or... the client maliciously called this server, but is being blocked by the authorization policies. IBAC has saved the day!
:::

<details>
<summary>Optional: see the generated authorization policies</summary>
Otterize automatically generated authorization policies according to your declared intents.

To list all generated authorization policies run:

```bash
kubectl get authorizationpolicies.security.istio.io -n otterize-visual-tutorial-istio
```

Let's inspect one of these authorization policies with:
```bash
kubectl get authorizationpolicies.security.istio.io -n otterize-visual-tutorial-istio authorization-policy-to-productcatalogservice-from-checkoutservice.otterize-visual-tutorial-istio -o yaml
```

The result should be:

```yaml
apiVersion: security.istio.io/v1
kind: AuthorizationPolicy
metadata:
  name: authorization-policy-to-productcatalogservice-from-checkoutservice.otterize-visual-tutorial-istio
  namespace: otterize-visual-tutorial-istio
...
spec:
  rules:
  - from:
    - source:
      principals:
      - cluster.local/ns/otterize-visual-tutorial-istio/sa/checkoutservice-service-account
  to:
    - operation:
      methods:
      - POST
      paths:
      - /products
  selector:
    matchLabels:
      intents.otterize.com/server: productcatalogservic-otterize-visual-tuto-99a036
```
</details>

## What's next

- Learn how to [roll out IBAC with Kubernetes network policies](/quick-visual-tutorials/visual-ibac-network-policies), automatically generating and updating network policies.
- Learn how to [roll out secure access for Kafka in Kubernetes](/quick-visual-tutorials/visual-ibac-kafka-k8s), automating both mTLS for client authentication and the ACLs built into Kafka.

## Teardown

To remove the deployed demo run:

```bash
kubectl delete -n otterize-vizual-tutorial-istio -f https://docs.otterize.com/code-examples/ibac-for-istio/all.yaml
kubectl delete -n otterize-vizual-tutorial-istio -f https://docs.otterize.com/code-examples/ibac-for-istio/demo-app.yaml
```