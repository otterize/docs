---
sidebar_position: 4
title: "Visual tutorial: IBAC with Istio authorization policies"
sidebar_label: "IBAC with Istio authorization policies"
---

import CodeBlock from "@theme/CodeBlock";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Istio authorization policies are a powerful and flexible tool, but using them to achieve a zero-trust architecture with fine-grained pod-to-pod access control can be difficult to implement and maintain.

In this tutorial, we will show you how to roll out Istio authorization policies with intent-based access control (IBAC).
With IBAC, you won't need to manually keep track of pod labels or service accounts. You won't need to manage Istio authorization policies at all &mdash; they'll be generated and managed automatically. We'll even show you how to generate policies for all discovered traffic in the cluster with just one command.

By the end of this tutorial, each server in the cluster will only allow the incoming calls declared by client services in their client intents files, and block any undeclared (unintended) calls. Call declarations, and the authorization policies they'll generate, will be specific not just down to the server but also to the HTTP path and method.

All the capabilities of IBAC for Istio are within Otterize OSS, while the access graph in Otterize Cloud will guide us
visually in these steps and support us in the process of zero trust adoption in our cluster without breaking anything.

You will:
1. Install Otterize OSS in your Kubernetes cluster, integrated to your Otterize Cloud account.
2. Install and configure Istio into your cluster.
3. Deploy, as in previous tutorials, a set of services based on the [Google microservices demo](https://github.com/GoogleCloudPlatform/microservices-demo)
(a simple e-commerce application) to your Kubernetes cluster.
4. View, within Otterize Cloud, the traffic in your cluster.
5. Declare one intent in your cluster just to see how the generated authorization policies affect the cluster.
6. Generate client intents for all traffic in the cluster to achieve zero trust in one command.

## Prerequisites

<details>
<summary>Prepare a Kubernetes cluster</summary>

Before you start, you'll need a Kubernetes cluster. Having a cluster with a [CNI](https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/) that supports [NetworkPolicies](https://kubernetes.io/docs/concepts/services-networking/network-policies/) isn't required for this tutorial, but is recommended so that your cluster works with other tutorials.

{@include: ../_common/cluster-setup.md}
</details>

<details>
<summary>Create an Otterize Cloud account</summary>

{@include: ../_common/create-account.md}

</details>

<details>
<summary>Install Otterize OSS </summary>

{@include: ../_common/install-otterize-from-cloud.md}

</details>

<details>
<summary>Install the Otterize CLI</summary>

{@include: ../_common/install-otterize-cli.md}

</details>

## Install and configure Istio
<details>
<summary>Install Istio in the cluster via Helm</summary>

{@include: ../_common/install-istio.md}

</details>

:::tip
HTTP request paths and methods aren't exported in Envoy's connection metrics by default, but we do want to capture those
details when creating the network map. That way we not only have better visibility of the calling patterns,
e.g. in the access graph, but we can also use that information to automatically capture fine-grained intents and
use them to generate Istio authorization policies.
:::

<details>
<summary>Enhance Istio exported metrics with HTTP methods and request paths</summary>

Apply this configuration in the `istio-system` namespace, propagating it to all namespaces covered by the mesh.

```
kubectl apply -f ${ABSOLUTE_URL}/code-examples/network-mapper/istio-telemetry-enablement.yaml
```

```yaml
{@include: ../../static/code-examples/network-mapper/istio-telemetry-enablement.yaml}
```

</details>

## Deploy demo to simulate traffic
<details>
<summary>Create a namespace for our demo application and label it for Istio injection</summary>

```bash
kubectl create namespace otterize-visual-tutorial-istio
kubectl label namespace otterize-visual-tutorial-istio istio-injection=enabled
```
</details>

<details>
<summary>Deploy the demo set of services</summary>

```
kubectl apply -n otterize-visual-tutorial-istio -f ${ABSOLUTE_URL}/code-examples/ibac-for-istio/demo-app.yaml
```
</details>

## Seeing the access graph

In the Otterize Cloud web app, within the [Clusters tab](https://app.otterize.com/clusters), your cluster should be displaying all three Otterize OSS
operators &mdash; the intents operator, network mapper, and credentials operator &mdash; in the green connected state.

![Access graph](/img/quick-tutorials/istio-visual-tutorial/cluster-connected.png)

Now, let's head back to the [access graph](https://app.otterize.com/access-graph). If necessary, make sure to select your cluster from the dropdown menu.
You should see the map for the demo running in your cluster:

![Access graph](/img/quick-tutorials/istio-visual-tutorial/phase-0.png)

Each service is shown as a node in the access graph, while the dashed lines (edges) connecting the services show access between them, as detected by the network mapper.

The lines are dashed because the client services are missing intent declarations: we've *discovered* their intents to call the servers, but they haven't *declared* those intents.

Otterize can configure several access control mechanisms, such as network policies and Kafka ACLs, and the access graph can take into account their combined state. But for this demo, we're only using Istio authorization policies, so let's adjust the access graph view to only take these Istio policies into account: in the Istio policies section at the top, toggle on "Use in access graph"; and in the sections for network
policies and Kafka ACLs, toggle off "Use in access graph".

![Access graph](/img/quick-tutorials/istio-visual-tutorial/access-graph-panel.png)

Finally, let's filter out all but the `otterize-visual-tutorial-istio` namespace, as that's where the functional services are running. Select that namespace from the namespace filter at the top.

## Try out IBAC with shadow mode

Our mission in this tutorial is to achieve zero trust in our cluster, but we don't want to break anything in the process. So we'll start off by rolling out IBAC for just one service: only it will be protected from any unauthorized access.

Even then, one of the biggest challenges in rolling out zero trust is that Istio authorization policies, like network policies and Kafka ACLs, can't let us know what would be blocked *before* we actually block it.

Otterize solves this problem by providing a "shadow mode" enforcement. In shadow mode, Otterize doesn't actually generate
Istio authorization policies from client intents declarations, so nothing is actually blocked.
But Otterize still sees any intent declarations that *would* generate policies, so the access graph can preview what access would be blocked or enabled if we were to generate policies.

## Choose a first service to protect

Let's pick one service and manually protect it, before automating the process for the whole cluster.
We will start with the `recommendationservice`. Find it in the access graph. If you have a large graph, you can always type its name in the search box on the left and select it to bring it into view. You can also zoom in to see it larger:

![Access graph](/img/quick-tutorials/istio-visual-tutorial/recommendation-graph-phase-0.png)

Click on the `recommendationservice` to see more details:

![Access graph](/img/quick-tutorials/istio-visual-tutorial/recommendation-service-phase-0.png)

At the  bottom of this panel, you can see it as a server (on the left) receiving requests, and as a client (on the right) sending requests.

As a server, the access graph tells you it's currently unprotected. Why?
- There is no default `allow nothing` authorization policy configured for the cluster, as we informed the graph in the "Istio policies" section at the top right. That's appropriate for our situation: we want to roll out protection one service at a time, without breaking access to the others.
- The first authorization policy would protect this server, but no such policies would be created for it right now if enforcement were turned on, since no clients have declared their intents to call it. We'll do that in the next step.

At the very bottom of the server section, we can see that this service is called by the `frontend`
service, which uses the `GET` method to access the `/recommendations` resource. Let's click the dashed line from `frontend`
to `recommendationservice` to see the details of the access:

![Access graph](/img/quick-tutorials/istio-visual-tutorial/frontend-recommendation-phase-0.png)

We see that the network mapper *discovered* the intent by the `frontend` to `GET` `/recommendations` on the `recommendationservice`, but the `frontend` did not *declare* it.

(Note also that the `recommendationservice` *as a client* is also not blocked by any authorization policy.)

## Declare your intentions!

As suggested by the access graph, we will now take the intent we just *discovered* and *declare* that the `frontend` service intends to
call the `recommendationservice` via `GET` requests to the HTTP resource at `/recommendations`:

```yaml
{@include: ../../static/code-examples/ibac-for-istio/phase-1.yaml}
```

We expect this will eventually provide secure access: **allowing** the intended access from the `frontend`, while **protecting** the `recommendationservice` from unintended access (since it will now have an authorization policy on it).
Why eventually? Because we'll still need to go from shadow mode to actual enforcement, after getting reassured in shadow mode that intentional calls won't be blocked.

Apply the above client intents file with:
```bash
kubectl apply -n otterize-visual-tutorial-istio -f ${ABSOLUTE_URL}/code-examples/ibac-for-istio/phase-1.yaml
```

Look at the access graph again:

![Access graph](/img/quick-tutorials/istio-visual-tutorial/phase-1.png)

The green line from `frontend` to `recommendationservice` is no longer dashed, but rather **solid**: the desired access we discovered has now been declared.

Click on that solid `frontend` &rarr; `recommendationservice` line:
<img src="/img/quick-tutorials/istio-visual-tutorial/frontend-recommendation-applied.png" alt="Discovered intents" width="600"/>

We can see that:
- The *discovered* intent to access is now also *declared*, and as a result...
- ...this call will be guaranteed access even after enforcement is turned on: the arrow is now **solid** green.

Click on the `recommendationservice` itself:
<img src="/img/quick-tutorials/istio-visual-tutorial/recommendation-access-state.png" alt="Discovered intents" width="600"/>

The access graph shows us:
- This service is still not currently protected: after all, we're in shadow mode, without enforcement, so there are no authorization policies blocking unintended access.
- The "Istio policies" tag indicates that specifically it's not currently protected by Istio authorization policies. Had we been using other access controls, you would see the protection status for those too.
- There is no longer a warning about the `recommendationservice` remaining unprotected once enforcement is turned on.
- From this server's perspective, all's ready to activate enforcement.

We now have **a green light for turning on enforcement** and protecting this service from any unintended calls without breaking its intended clients.

:::tip Ready to enforce?
We could certainly turn on enforcement now.

But instead, let's first protect another service, just to show how the access graph would warn us if we're not ready to turn on enforcement.
:::

### Declare more intents

We can see in the access graph that the `recommendationservice` in turn calls the `productcatalogservice`, sending `GET` requests to the resource at `/similar-products`, so let's declare that intent:

```yaml
{@include: ../../static/code-examples/ibac-for-istio/phase-2.yaml}
```

Apply this intents file with:
```bash
kubectl apply -n otterize-visual-tutorial-istio -f ${ABSOLUTE_URL}/code-examples/istio-visual-tutorial/phase-2.yaml
```
Look at the access graph again:

![Access graph](/img/quick-tutorials/istio-visual-tutorial/phase-2.png)

As before, the line from `recommendationservice` &rarr; `productcatalogservice` is now solid green line, with no warnings. That's what we expect when we properly declare a discovered intent.

But two other lines, `frontend` &rarr; `productcatalogservice` and `checkoutservice` &rarr; `productcatalogservice`, have turned orange. And a red warning has shown up on the `productcatalogservice`. Why?

Click on one of those orange lines:
<img src="/img/quick-tutorials/istio-visual-tutorial/frontend-productactalogservice-missing-intent.png" alt="Discovered intents" width="600"/>

- There is no declaration of the discovered `GET /products` calls from the `frontend` to the `productcatalogservice`.
- This undeclared access is not blocked *now* &mdash; because we're still in shadow mode (otherwise the line would have been red).
- But access *would* be blocked once enforcement is turned on. To prevent that, we're told to declare the intent for this call.

Click on the `productcatalogservice` to read its warnings, and what's there and what's missing:
<img src="/img/quick-tutorials/istio-visual-tutorial/productcatalog-would-block.png" alt="Discovered intents" width="600"/>

- We can see it's not protected now, again because we're in shadow mode.
- But we can also see it *would* block some clients once protection is enabled.
- We can see that the `recommendationservice` will be allowed to `GET /similar-products`, but no other clients are guaranteed access.
- And there is an explicit warning to apply the missing intents from **all** the clients of the `productcatalogservice` before turning on enforcement.

Let's declare those intents from the `frontend` and `checkoutservice` clients:
<Tabs>
<TabItem value="frontend" label="frontend" default>

```yaml
{@include: ../../static/code-examples/ibac-for-istio/phase-3-frontend.yaml}
```
</TabItem>
<TabItem value="checkout-service" label="checkoutservice" default>

```yaml
{@include: ../../static/code-examples/ibac-for-istio/phase-3-checkout.yaml}
```
</TabItem>
</Tabs>

Apply these intents files with:
```bash
kubectl apply -n otterize-visual-tutorial-istio -f ${ABSOLUTE_URL}/code-examples/ibac-for-istio/phase-3.yaml
```

Let's go back to the access graph:

![Access graph](/img/quick-tutorials/istio-visual-tutorial/phase-3.png)

Note that all arrows are now green again; specifically, the ones to the `productcatalogservice` are also solid, indicating all access has been declared.

Click on the `productcatalogservice`:

![Access graph](/img/quick-tutorials/istio-visual-tutorial/productcatalog-service-all-green.png)

All is well again:
- The `productcatalogservice` will be protected, without blocking its 3 declared clients, once enforcement is turned on. We have **a green light to activate enforcement**.
- Each client's access will be limited to the HTTP resource and method declared in its intents file. Clients have the intended access and nothing more (least privilege).

:::tip We can now see how to roll out IBAC gradually:
1. Pick a service to protect.
2. Make sure all its clients declare their intents to call it.
3. When you're ready, and the access graph shows green solid arrows without warnings, turn on enforcement.

The access graph and shadow mode allow us to gain confidence by showing what would happen, highlighting any problems, and pointing to their fixes.
:::

### Optional: protect everything easily
Since Otterize already knows the problems and their fixes, could we somehow automatically bootstrap this for the whole cluster and protect all services, without breaking any intended calls? Yes!

The network mapper keeps track of all attempted calls, after all: those are the discovered intents. If you are confident that all intended call patterns have been exercised while the network mapper was running (so it could capture them), and all the calls it saw are intended and appropriate, you can use that information to automatically generate intent declarations and apply them.

Let's use the [Otterize CLI](/reference/cli) to export all discovered intents as YAML declarations:
```bash
otterize network-mapper export -n otterize-visual-tutorial-istio --output-type dir --output intents
```

You can apply them using:
```bash
kubectl apply -f intents
```

Or, equivalently, just use the already-generated intents files included in this docs location:
```bash
kubectl apply -n otterize-visual-tutorial-istio -f ${ABSOLUTE_URL}/code-examples/ibac-for-istio/all.yaml
```

<details>
<summary>If you are curious, have a look at the intents files generated by this single command:</summary>

<Tabs>
<TabItem value="frontend" label="frontend" default>

```yaml
{@include: ../../static/code-examples/ibac-for-istio/intents/frontend.yaml}
```
</TabItem>
<TabItem value="checkout-service" label="checkoutservice" default>

```yaml
{@include: ../../static/code-examples/ibac-for-istio/intents/checkoutservice.yaml}
```
</TabItem>
<TabItem value="recommendation-service" label="recommendationservice" default>

```yaml
{@include: ../../static/code-examples/ibac-for-istio/intents/recommendationservice.yaml}
```
</TabItem>
<TabItem value="cart-service" label="cartservice" default>

```yaml
{@include: ../../static/code-examples/ibac-for-istio/intents/cartservice.yaml}
```
</TabItem>
<TabItem value="load-generator" label="loadgenerator" default>

```yaml
{@include: ../../static/code-examples/ibac-for-istio/intents/loadgenerator.yaml}
```
</TabItem>
</Tabs>
</details>

Look at the access graph again:

![Access graph](/img/quick-tutorials/istio-visual-tutorial/phase-4.png)

The graph confirms that all services would be protected, and no intended calls would be blocked, once we apply protection.

:::tip
In essence, in one shot, we've declared that all the traffic in the environment where the mapper was running is all the intended traffic: all these calls, and no other calls, should be allowed.
:::


## Enable enforcement
With the confidence we've gained, let's enable enforcement (via Istio authorization policies) by upgrading your Otterize installation and setting the Helm chart flag `intentsOperator.operator.mode=defaultActive`.

At the top of the access graph, click the **Configure cluster** button; or in the clusters page, click on the **Connection guide &rarr;** link for your cluster.

Then run the Helm commands shown there, and specifically follow the instructions to install Otterize <b>with enforcement on</b> (use the toggle to make `Enforcement mode: active`)

Let's look at the access graph again:

![Access graph](/img/quick-tutorials/istio-visual-tutorial/phase-5.png)

Note that all of the servers (the server sides of the services) are shown in green, as protected. And no client call attempts (discovered by the network mapper) are being blocked. This is what a service-to-service zero-trust architecture looks like.

:::tip How would blocked access attempts look now?
From now on, if a client attempts a server call that wasn't covered by one of the declared intents, that would be discovered by the network mapper and show up as (new) discovered intents. Remember that the network mapper discovers attempted access, not just successful access. In this case, a red line would appear from that client to that server, and a red warning would show up on the server and client, saying: calls from that client are being blocked.

That may be because:
- The calls were legitimate, but were missed when intents were generated because they didn't happen when the network mapper was building its map from which the intents were bootstrapped. In that case, you may choose to generate all the intents again, or or just create and apply the new ones manually.
- Or... the client maliciously called this server, but is being blocked by the authorization policies. IBAC has saved the day!
:::

<details>
<summary>Optional: see the generated authorization policies</summary>
Otterize automatically generated authorization policies according to your declared intents.

To list all generated authorization policies run:

```bash
kubectl get authorizationpolicies.security.istio.io -n otterize-visual-tutorial-istio
```

Let's inspect one of these authorization policies with:
```bash
kubectl get authorizationpolicies.security.istio.io -n otterize-visual-tutorial-istio authorization-policy-to-productcatalogservice-from-checkoutservice.otterize-visual-tutorial-istio -o yaml
```

The result should be:

```yaml
apiVersion: security.istio.io/v1
kind: AuthorizationPolicy
metadata:
  name: authorization-policy-to-productcatalogservice-from-checkoutservice.otterize-visual-tutorial-istio
  namespace: otterize-visual-tutorial-istio
...
spec:
  rules:
  - from:
    - source:
      principals:
      - cluster.local/ns/otterize-visual-tutorial-istio/sa/checkoutservice-service-account
  to:
    - operation:
      methods:
      - POST
      paths:
      - /products
  selector:
    matchLabels:
      intents.otterize.com/server: productcatalogservic-otterize-visual-tuto-99a036
```
</details>

## What's next

- Learn how to [roll out IBAC with Kubernetes network policies](/quick-visual-tutorials/visual-ibac-network-policies), automatically generating and updating network policies.
- Learn how to [roll out secure access for Kafka in Kubernetes](/quick-visual-tutorials/visual-ibac-kafka-k8s), automating both mTLS for client authentication and the ACLs built into Kafka.

## Teardown

To remove the deployed demo run:

```bash
kubectl delete -n otterize-vizual-tutorial-istio -f ${ABSOLUTE_URL}/code-examples/ibac-for-istio/all.yaml
kubectl delete -n otterize-vizual-tutorial-istio -f ${ABSOLUTE_URL}/code-examples/ibac-for-istio/demo-app.yaml
```