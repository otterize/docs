---
sidebar_position: 4
title: "Visual tutorial: IBAC with Istio authorization policies"
sidebar_label: "IBAC with Istio authorization policies"
---

import CodeBlock from "@theme/CodeBlock";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Istio authorization policies are a powerful and flexible tool, but using them to achieve a zero-trust architecture with fine-grained pod-to-pod access control can be difficult to implement and maintain.

In this tutorial, we will show you how to roll out Istio authorization policies with intent-based access control (IBAC).
With IBAC, you won't need to manually keep track of pod labels or service accounts. You won't need to manage Istio authorization policies at all &mdash; they'll be generated and managed automatically! We'll even show you how to generate policies for all discovered traffic in the cluster with just one command.

By the end of this tutorial, each server in the cluster will only allow the incoming calls declared by client services in their client intents files, and block any undeclared (unintentional) calls. Call declarations, and the authorization policies they'll generate, will specify not just the server but also the HTTP path and method.

All the capabilities of IBAC for Istio are within Otterize OSS, while the access graph in Otterize Cloud will guide us visually in these steps.

You will:
1. Install Otterize OSS in your Kubernetes cluster, integrated to your Otterize Cloud account.
2. View, within Otterize Cloud, the traffic in your cluster.
3. Declare one intent just to see how the generated authorization policies affect the cluster.
4. Generate client intents for all traffic in the cluster to achieve zero trust in one command.

## Prerequisites

<details>
<summary>Prepare a Kubernetes cluster</summary>

Before you start, you'll need a Kubernetes cluster. Having a cluster with a [CNI](https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/) that supports [NetworkPolicies](https://kubernetes.io/docs/concepts/services-networking/network-policies/) isn't required for this tutorial, but is recommended so that your cluster works with other tutorials.

{@include: ../_common/cluster-setup.md}
</details>

<details>
<summary>Create an Otterize Cloud account</summary>

{@include: ../_common/create-account.md}

</details>

<details>
<summary>Install Otterize OSS <b>with Istio watcher active</b></summary>

{@include: ../_common/install-otterize-from-cloud-with-istiowatcher.md}

</details>

<details>
<summary>Install the Otterize CLI</summary>

{@include: ../_common/install-otterize-cli.md}

</details>

## Install and configure Istio
<details>
<summary>Install Istio in the cluster via Helm</summary>

{@include: ../_common/install-istio.md}

</details>

<details>
<summary>Add HTTP methods and request paths to Istio exported metrics</summary>

Apply this configuration in the `istio-system` namespace, propagating it to all namespaces covered by the mesh.

```
kubectl apply -f https://docs.otterize.com/code-examples/network-mapper/istio-telemetry-enablement.yaml
```

```yaml
{@include: ../../static/code-examples/network-mapper/istio-telemetry-enablement.yaml}
```

</details>

:::tip
HTTP request paths and methods aren't exported in Envoy's connection metrics by default, but we do want to capture those
details when creating the network map. That way we not only have better visibility of the calling patterns,
e.g. in the access graph, but we can also use that information to automatically capture fine-grained intents and
use them to generate Istio authorization policies.
:::

## Deploy demo to simulate traffic
<details>
<summary>Create a namespace for our demo application and label it for Istio injection</summary>

```bash
kubectl create namespace otterize-visual-tutorial-istio
kubectl label namespace otterize-visual-tutorial-istio istio-injection=enabled
```
</details>

<details>
<summary>Deploy the demo set of services</summary>

```
kubectl apply -n otterize-visual-tutorial-istio -f https://docs.otterize.com/code-examples/ibac-for-istio/demo-app.yaml
```
</details>

## Seeing the access graph

In the Otterize Cloud UI, your [cluster](https://app.otterize.com/clusters) should now show all 3 Otterize OSS operators &mdash; the intents operator, network mapper, and credentials operator &mdash; as connected, with a green status.

And when you go back to the [access graph](https://app.otterize.com/access-graph) (and select your cluster from the dropdown, if needed), you should see the following map for the demo running in your cluster:

![Access graph](/img/quick-tutorials/istio-visual-tutorial/phase-0.png)

Each service is shown as a node in the access graph, while the dashed lines (edges) connecting the services show access between them, as detected by the network mapper.

The lines are dashed because the client services are missing intent declarations: we've discovered their intents to call the servers, but they haven't declared those intents.

We need to adjust the access graph view to take into account Istio authorization policies, so turn on the Istio policies "Use in access graph" toggle and turn off the network policies and Kafka ACLs toggle buttons (to focus only on Istio).

![Access graph](/img/quick-tutorials/istio-visual-tutorial/access-graph-panel.png)

## Try out IBAC with shadow mode

Now let's start to roll out access controls, but remain in shadow mode: no actual enforcement of controls, yet. In shadow mode, Otterize doesn't actually generate access controls (in this case, Istio authorization policies) from client intents declarations, but the access graph still shows you the effects those declarations would have.

We'll declare that the `frontend` intends to call the `recommendationservice` by sending `GET` requests to the HTTP resource at `/recommendations`:

```yaml
{@include: ../../static/code-examples/ibac-for-istio/phase-1.yaml}
```

We expect this will provide secure access, allowing the intended access from the `frontend` while protecting the `recommendationservice` from unintended access.

Apply the above client intents file with:
```bash
kubectl apply -n otterize-visual-tutorial-istio -f https://docs.otterize.com/code-examples/ibac-for-istio/phase-1.yaml
```

Look at the access graph again:

![Access graph](/img/quick-tutorials/istio-visual-tutorial/phase-1.png)

The green line from `frontend` to `recommendationservice`, representing the discovered intent from the network mapper, is no longer dashed, but rather **solid**: the access we discovered was needed has now been declared.

Click on that `frontend` &rarr; `recommendationservice` line:
<img src="/img/quick-tutorials/istio-visual-tutorial/frontend-recommendation-applied.png" alt="Discovered intents" width="600"/>

- We can see the `frontend` calls the `recommendationservice`, and has declared that intent, so it will be guaranteed access even once enforcement is turned on.

Click on the `recommendationservice` itself:
<img src="/img/quick-tutorials/istio-visual-tutorial/recommendation-access-state.png" alt="Discovered intents" width="600"/>

- We can see this service is not currently protected: after all, we're in shadow mode, and there are no authorization policies blocking unintended access.
- We can also see it would not block any clients once protection is enabled.
- And there is no warning about it remaining unprotected once enforcement is turned on. We have **a green light**, at least as far as this service goes, **for turning on enforcement** and protecting this service from any unintended calls.

### Declare more intents
We can see in the access graph that the `recommendationservice` in turn calls the `productcatalogservice`, sending `GET` requests to the resource at `/similar-products`, so let's declare that intent:

```yaml
{@include: ../../static/code-examples/ibac-for-istio/phase-2.yaml}
```

Apply this intents file with:
```bash
kubectl apply -n otterize-visual-tutorial-istio -f https://docs.otterize.com/code-examples/istio-visual-tutorial/phase-2.yaml
```
Look at the access graph again:

![Access graph](/img/quick-tutorials/istio-visual-tutorial/phase-2.png)

As before, the line from `recommendationservice` &rarr; `productcatalogservice` is now solid green line, with no warnings. That's what we expected when we properly declare a discovered intent.

But two other lines, `frontend` &rarr; `productcatalogservice` and `checkoutservice` &rarr; `productcatalogservice`, have turned orange. And a red warning has shown up on the `productcatalogservice`. Why?

Click on one of those orange lines:
<img src="/img/quick-tutorials/istio-visual-tutorial/frontend-productactalogservice-missing-intent.png" alt="Discovered intents" width="600"/>

- There is no declaration of the discovered `GET` calls from the `frontend` to the `productcatalogservice` at `/products`.
- This undeclared access is not blocked *now* &mdash; because we're still in shadow mode (otherwise the line would have been red).
- But access *would* be blocked once enforcement is turned on. To prevent that, we're told to declare the intent for this call.

Click on the `productcatalogservice`:
<img src="/img/quick-tutorials/istio-visual-tutorial/productcatalog-would-block.png" alt="Discovered intents" width="600"/>

- We can see it's not protected now, again because we're in shadow mode.
- But we can also see it *would* block any clients once protection is enabled.
- And there is an explicit warning to apply the missing intents from all its clients before turning on enforcement.


Let's declare those intents from the `frontend` and `checkoutservice` clients.

<Tabs>
<TabItem value="frontend" label="frontend" default>

```yaml
{@include: ../../static/code-examples/ibac-for-istio/phase-3-frontend.yaml}
```
</TabItem>
<TabItem value="checkout-service" label="checkoutservice" default>

```yaml
{@include: ../../static/code-examples/ibac-for-istio/phase-3-checkout.yaml}
```
</TabItem>
</Tabs>

Apply these intents files with:
```bash
kubectl apply -n otterize-visual-tutorial-istio -f https://docs.otterize.com/code-examples/ibac-for-istio/phase-3.yaml
```

Let's go back to the access graph:

![Access graph](/img/quick-tutorials/istio-visual-tutorial/phase-3.png)

Click on the `productcatalogservice`:

![Access graph](/img/quick-tutorials/istio-visual-tutorial/productcatalog-service-all-green.png)

All is well again: the `productcatalogservice` will be protected, and its 3 declared clients will have access, after enforcement is turned on.
Each client's access is limited to the HTTP resource and method declared in its intents file.

:::tip We can now see how to roll out IBAC gradually:
1. Pick a service to protect.
2. Make sure all its clients declare their intents to call it.
3. When you're ready, and the access graph shows green solid arrows without warnings, turn on enforcement.

The access graph and shadow mode allow us to gain confidence by showing what would happen, highlighting any problems, and pointi ng to their fixes.
:::


### Protect everything easily
Since Otterize already knows the problems and their fixes, could we somehow automatically bootstrap this for the whole cluster and protect all services, without breaking any intended calls? Yes!

The network mapper keeps track of all attempted calls, after all: those are the discovered intents. If you are confident that all intended call patterns have been exercised while the network mapper was running (so it could capture them), and all the calls it saw are intended and appropriate, you can use that information to automatically generate intent declarations and apply them.

Let's use the [Otterize CLI](/reference/cli) to export all discovered intents as YAML declarations:
```bash
otterize network-mapper export -n otterize-visual-tutorial-istio --output-type dir --output intents
```

You can apply them using:
```bash
kubectl apply -f intents
```

Or, equivalently, just use the already-generated intents files included in this docs location:
```bash
kubectl apply -n otterize-ecom-demo -f https://docs.otterize.com/code-examples/ibac-for-istio/all.yaml
```

Look at the access graph again:

![Access graph](/img/quick-tutorials/istio-visual-tutorial/phase-4.png)

The graph confirms that all services would be protected, and no intended calls would be blocked, once we apply protection.

:::tip
In essence, in one shot, we've declared that all the traffic in the environment where the mapper was running is all the intended traffic: all these calls, and no other calls, should be allowed.
:::


## Enable enforcement
With the confidence we've gained, let's enable enforcement (via Istio authorization policies) by upgrading your Otterize installation to remove the `intentsOperator.operator.enableEnforcement=false` flag.

At the top of the access graph, click the **Configure cluster** button; or in the clusters page, click on the **Connection guide &rarr;** link for your cluster.

Then run the Helm commands shown there, and specifically follow the instructions to install Otterize <b>with enforcement on</b> (not in shadow mode). Namely, <b>omit</b> the following flag in the Helm command:

`--set intentsOperator.operator.enableEnforcement=false`

Let's look at the access graph again:

![Access graph](/img/quick-tutorials/shadow-mode/phase-5.png)

Note that all (but two) of the servers are shown in green, as protected. And no client call attempts (discovered by the network mapper) are being blocked. This is what a service-to-service zero-trust architecture looks like.

:::tip How would blocked access attempts look now?
From now on, if a client attempts a server call that wasn't covered by one of the declared intents, that would be discovered by the network mapper and show up as (new) discovered intents. Remember that the network mapper discovers attempted access, not just successful access. In this case, a red line would appear from that client to that server, and the lock on that server would turn red: calls from that client are being blocked.

That may be because:
- The calls were legitimate, but were missed when intents were generated because they didn't happen when the network mapper was building its map from which the intents were bootstrapped. In that case, you may choose to generate all the intents again, or or just create and apply the new ones manually.
- Or... the client maliciously called this server, but is being blocked by the authorization policies. IBAC has saved the day!
:::

<details>
<summary>Optional: see the generated authorization policies</summary>
Otterize automatically generated authorization policies according to your declared intents.

To list all generated authorization policies run:

```bash
kubectl get authorizationpolicies.security.istio.io -n otterize-visual-tutorial-istio
```

Let's inspect one of these authorization policies with:
```bash
kubectl get authorizationpolicies.security.istio.io -n otterize-visual-tutorial-istio authorization-policy-to-productcatalogservice-from-checkoutservice.otterize-visual-tutorial-istio -o yaml
```

The result should be:

```yaml
apiVersion: security.istio.io/v1
kind: AuthorizationPolicy
metadata:
  name: authorization-policy-to-productcatalogservice-from-checkoutservice.otterize-visual-tutorial-istio
  namespace: otterize-visual-tutorial-istio
...
spec:
  rules:
  - from:
    - source:
      principals:
      - cluster.local/ns/otterize-visual-tutorial-istio/sa/checkoutservice-service-account
  to:
    - operation:
      methods:
      - POST
      paths:
      - /products
  selector:
    matchLabels:
      intents.otterize.com/server: productcatalogservic-otterize-visual-tuto-99a036
```
</details>

## What's next

- Learn how to [roll out IBAC with Kubernetes network policies](/quick-visual-tutorials/visual-ibac-network-policies), automatically generating and updating network policies.
- Learn how to [roll out secure access for Kafka in Kubernetes](/quick-visual-tutorials/visual-ibac-kafka-k8s), automating both mTLS for client authentication and the ACLs built into Kafka.

## Teardown

To remove the deployed demo run:

```bash
kubectl delete -n otterize-vizual-tutorial-istio -f https://docs.otterize.com/code-examples/ibac-for-istio/all.yaml
kubectl delete -n otterize-vizual-tutorial-istio -f https://docs.otterize.com/code-examples/ibac-for-istio/demo-app.yaml
```