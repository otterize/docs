---
sidebar_position: 4
title: Simple mTLS deployment
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Otterize can automatically provision mTLS credentials by using the service identities implied by Kubernetes.
This tutorial will walk you through deploying mTLS certificates on a sample client-server deployment using the [Otterize credentials operator](/reference/configuration/credentials-operator).
You can configure this operator to use a [local SPIRE server](https://spiffe.io/docs/latest/spire-about/) to issue and manage certificates, or to use the Otterize Cloud service to manage this for you.
You can read more about these options in the [cryptographic credentials documentation](/security#cryptographic-credentials).

In this tutorial, we will:

- Deploy client and server pods communicating over HTTP with mTLS.
- See that mTLS credentials were autogenerated.

We'll start by installing Otterize. You can do so just using Otterize OSS, without it to Otterize Cloud, and use SPIRE for certificates. Or you can do so with Otterize OSS connected to Otterize Cloud, which adds web visualization as well as the *option* of using Cloud-managed credentials. (You can also connect to Cloud but still use SPIRE; refer to the [cryptographic credentials documentation](/security#cryptographic-credentials).)

<details>
<summary>Install Otterize in your cluster, <b>without</b> Otterize Cloud</summary>

:::note Basic system memory requirements
Otterize requires about 200 MBs and 200 mCPU for all components (including a SPIRE deployment) to install and run properly on Minikube and EKS clusters.
:::

{@include: ../_common/install-otterize.md}

</details>

Or choose to include browser visualization and Cloud-managed credentials:

<details>
<summary>Install Otterize in your cluster, <b>with</b> Otterize Cloud</summary>

####  Create an Otterize Cloud account

{@include: ../_common/create-account.md}

#### Install Otterize OSS, connected to Otterize Cloud

{@include: ../_common/install-otterize-from-cloud.md}

</details>

## Deploy the example

Our example consists of two pods, "client" and "server", communicating over HTTP with mTLS.
Otterize makes mTLS easy, requiring just 3 simple changes to a client pod spec:
1. **Generate credentials**: add the `credentials-operator.otterize.com/tls-secret-name` annotation, which tells the Otterize
   credentials operator to generate mTLS credentials, and to store them in a Kubernetes secret
   whose name is the value of this annotation.
2. **Expose credentials in a volume**: add a volume containing this secret to the pod.
3. **Mount the volume**: mount the volume in every container in the pod.

<details>
<summary>Expand to see this structure</summary>

```yaml
spec:
  template:
    metadata:
      annotations:
        # highlight-next-line
        # 1. Generate credentials as a secret called "client-credentials-secret":
        credentials-operator.otterize.com/tls-secret-name: client-credentials-secret
        ...
    spec:
      volumes:
        # highlight-start
        # 2. Create a volume containing this secret:
        - name: otterize-credentials
          secret:
            secretName: client-credentials-secret
        # highlight-end
        ...
      containers:
        - name: client
          ...
          volumeMounts:
            # highlight-start
            # 3. Mount volume into container
            - name: otterize-credentials
              mountPath: /var/otterize/credentials
              readOnly: true
            # highlight-end
```
</details>

<details>
<summary>Expand to see the complete YAML files of the example</summary>
<Tabs>

<TabItem value="namespace.yaml" label="namespace.yaml" default>

```yaml
{@include: ../../static/code-examples/kafka-mtls/namespace.yaml}
```

</TabItem>

<TabItem value="client-deployment.yaml" label="client-deployment.yaml">

```yaml
{@include: ../../static/code-examples/kafka-mtls/client-deployment.yaml}
```

</TabItem>

<TabItem value="client-configmap.yaml" label="client-configmap.yaml">

```yaml
{@include: ../../static/code-examples/kafka-mtls/client-configmap.yaml}
```

</TabItem>
<TabItem value="client.js" label="client.js" default>

```js
const fs = require('fs');
const https = require('https');

const options = {
    hostname: 'server.otterize-tutorial-mtls',
    port: 443,
    path: '/hello',
    method: 'GET',
    cert: fs.readFileSync('/var/otterize/credentials/cert.pem'),
    key: fs.readFileSync('/var/otterize/credentials/key.pem'),
    ca: fs.readFileSync('/var/otterize/credentials/ca.pem')
}

const req = https.request(
    options,
    res => {
        res.on('data', function (data) {
            console.log(data.toString())
        });
    }
);

req.end();
```

</TabItem>
<TabItem value="server.js" label="server.js" default>

```js
const https = require(`https`);
const fs = require(`fs`);

const options = {
  key: fs.readFileSync('/var/otterize/credentials/key.pem'),
  cert: fs.readFileSync('/var/otterize/credentials/cert.pem'),
  ca: fs.readFileSync('/var/otterize/credentials/ca.pem'),
  requestCert: true
};

https.createServer(
    options,
    (req, res) => {
        const peerCert = req.connection.getPeerCertificate();
        const ownCert = req.connection.getCertificate();
        console.log("Received request:");
        console.log(peerCert.subject.CN + ":\t" + req.method + " " + req.url);
        if (req.url === '/hello') {
            res.writeHead(200);
            res.end('mTLS hello world\nfrom: ' + ownCert.subject.CN + '\nto client: ' + peerCert.subject.CN);
        } else {
            res.end();
        }
    }).listen(443);
```

</TabItem>
</Tabs>
</details>

Deploy the client and server using `kubectl`:
```bash
kubectl apply -f https://docs.otterize.com/code-examples/mtls/all.yaml
```

<details>
<summary>Optional: check deployment status</summary>

```bash
kubectl get pods -n otterize-tutorial-mtls
```
You should see
```
NAME                      READY   STATUS    RESTARTS   AGE
client-5689997b5c-grlnt   1/1     Running   0          35s
server-6698c58cbc-v9n9b   1/1     Running   0          34s
```
</details>

## Watch it in action

1. Confirm that the client can successfully call the server using HTTP with mTLS:

   ```bash
   kubectl logs --tail 3 -n otterize-tutorial-mtls deploy/client
   ```

   The client makes requests and prints out the server's response; our example server will respond with
   the `common name` of the server's certificate as well as the `common name` of the client's certificate:

   ```shell
   mTLS hello world
   from: server.otterize-tutorial-mtls          # server's common name in the certificate
   to client: client.otterize-tutorial-mtls     # client's common name in the certificate
   ```
2. You can also confirm on the server side that it sees requests from this authenticated client:
   ```bash
   kubectl logs --tail 1 -n otterize-tutorial-mtls deploy/server
   ```

   The example server logs the common name of every client that makes a request:

   ```shell
   client.otterize-tutorial-mtls:  GET /hello
   ```

:::info Certificate lifecycle management
Otterize leverages SPIRE or the Otterize Cloud credentials service to manage certificate lifecycle tasks such as rotation, revocation, etc.

We recommend reloading credentials before each use, as Otterize makes sure
the mounted credentials are constantly refreshed and up to date.
:::

## Inspect credentials

### Using Otterize Cloud

Otterize Cloud can be used for visualizing your network and overlay certificate information. When you browse to [https://app.otterize.com](https://app.otterize.com) you can see the access graph, showing you information about the services in your cluster, how they access each other, and so on. There are many other insights in the access graph, such as whether a service is or would be protected if enforcement were activated, or whether it would then block clients... but those are the subjects of the other tutorials.

If you click on the **server** service to see its details, you can expand and see the certificate details:

<img src="/img/quick-tutorials/mtls/creds.png" alt="Service details" width="600"/>

You can see the common name (CN) used as the service's identity. And you can also see the DNS names, which together with the CN encompass all the possible names attested for by this certificate.

### Using the command line

We can use `openssl` to inspect the generated credentials. The credentials are stored as a Kubernetes secret
and are then mounted as a file into the container.

1. Retrieve the credentials from the Kubernetes secret:

   ```shell
   kubectl get secret -n otterize-tutorial-mtls client-credentials-secret -o jsonpath='{.data.svid\.pem}' | base64 -d > svid.pem
   ```

2. Inspect the credentials with `openssl`:

   ```shell
   openssl x509 -in svid.pem -text | head -n 15
   ```
   You should see output similar to:
   ```x509
   Certificate:
       Data:
           Version: 3 (0x2)
           Serial Number:
               0b:eb:eb:4d:0e:02:7e:28:93:30:1c:55:26:22:8b:c7
           Signature Algorithm: sha256WithRSAEncryption
           Issuer: C = ..., O = ...
           Validity
               Not Before: Aug 24 12:19:57 2022 GMT
               Not After : Sep 23 12:20:07 2022 GMT
   # highlight-next-line
           Subject: C = ..., O = ..., CN = client.otterize-tutorial-mtls       # the client's name
           Subject Public Key Info:
               Public Key Algorithm: id-ecPublicKey
                   Public-Key: (256 bit)
                   pub:
   ```

3. You can see that Otterize generated an X.509 keypair using the pod's name ("client")
   and namespace ("otterize-tutorial-mtls"): `client.otterize-tutorial-mtls`.

<details>
<summary>Expand to see what happened behind the scenes</summary>

1. We annotated the pods to let Otterize know it should generate mTLS credentials.
2. The Otterize credentials operator:
    1. Generated matching mTLS credentials.
    2. Stored the mTLS credentials into Kubernetes secrets.
3. The secrets were mounted (separately) into each pod's container.
4. The pods communicated with each other using mutual TLS-authenticated HTTPS.

</details>

:::tip
Otterize defaults to generating credentials with an expiry time of 1 day. The certificates are
automatically refreshed before expiring, and therefore you must always read the credentials from file rather than caching them.

To set a longer expiration time, set the `credentials-operator.otterize.com/cert-ttl` annotation for your pods.
For more information, see [the documentation for the credentials operator](/reference/configuration/credentials-operator)
:::

## What's next

- Learn how to manage and [automatically provision mTLS](/quick-tutorials/k8s-mtls) credentials within a Kubernetes cluster.
- Enforce [secure Kafka access](/quick-tutorials/k8s-kafka-mtls) with mTLS.
- Learn more about how the [Otterize credentials operator](/reference/configuration/credentials-operator) works.

## Teardown

To remove the deployed examples run:

```bash
kubectl delete -f https://docs.otterize.com/code-examples/mtls/all.yaml
```
