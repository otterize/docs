---
sidebar_position: 5
title: Istio AuthorizationPolicy automation
---
import CodeBlock from "@theme/CodeBlock";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Otterize automates mTLS-based, HTTP-level pod-to-pod access control with Istio authorization (authZ) policies, within your Kubernetes cluster.

Implementing this kind of access control with Istio is complicated. For example, authorization policies select servers by label, and clients by service account, so both of those need to be created or updated.

To help you avoid manually managing complicated authorization policies per server, Otterize implements **intent-based access control** (IBAC).
You just declare what calls the client pods intend to make,
and everything is automatically wired together so only intended calls are allowed.

In this tutorial, we will:

- Deploy an Istio demo application with two client pods and one server pod.
- Declare that the first client intends to call the server with a specific HTTP path and method.
- See that an Istio authorization policy was autogenerated to allow just that, and to block the (undeclared) calls from the other client.

## Prerequisites

<details>
<summary>Prepare a Kubernetes cluster</summary>

Before you start, you'll need a Kubernetes cluster. Having a cluster with a [CNI](https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/) that supports [NetworkPolicies](https://kubernetes.io/docs/concepts/services-networking/network-policies/) isn't required for this tutorial, but is recommended so that your cluster works with other tutorials.

{@include: ../_common/cluster-setup.md}
</details>

You can now install (or reinstall) Otterize in your cluster, and optionally connect to Otterize Cloud. Connecting to Cloud lets you:
1. See what's happening visually in your browser, through the "access graph";
2. Avoid using SPIRE (which can be installed with Otterize) for issuing certificates, as Otterize Cloud provides a certificate service.

So either forego browser visualization and:

<details>
<summary>Install Otterize in your cluster, <b>without</b> Otterize Cloud</summary>

:::note Basic system memory requirements
Otterize requires about 200 MBs and 200 mCPU for all components (including a SPIRE deployment) to install and run properly on Minikube and EKS clusters.

{@include: ../_common/install-otterize-istio-enabled.md}

</details>

Or choose to include browser visualization and:

<details>
<summary>Install Otterize in your cluster, <b>with</b> Otterize Cloud</summary>

####  Create an Otterize Cloud account

{@include: ../_common/create-account.md}

#### Install Otterize OSS, connected to Otterize Cloud

{@include: ../_common/install-otterize-from-cloud-with-istio-enforcement.md}

</details>

## Install and configure Istio

<details>
<summary>Install Istio in the cluster via Helm</summary>

{@include: ../_common/install-istio.md}

</details>

## Deploy the two clients and the server

Deploy a simple example consisting of `client` and `other-client` calling `nginx` over HTTP:
```shell
kubectl apply -n otterize-tutorial-istio -f https://docs.otterize.com/code-examples/ibac-for-istio/all.yaml
```

## Apply intents
We will now declare that the **client** intends to call the **server** at a particular HTTP path using a specific HTTP method.

When the intents YAML is applied, creating a custom resource of type `ClientIntents`,
Otterize will add an Istio authorization policy to allow the intended call
(**client** &rarr; **server** with the declared path and method) and block all unintended calls (e.g., **client-other** &rarr; **server**).


1. Here is the `intents.yaml` declaration of the client, which we will apply below:
```yaml
{@include: ../../static/code-examples/ibac-for-istio/intents.yaml}
```

### See it in action

Keep an eye on the logs being tailed in the **[client-other]** terminal window,
   and apply this `intents.yaml` file in your **main terminal window** using:
   ```shell
   kubectl apply -f https://docs.otterize.com/code-examples/ibac-for-istio/intents.yaml
   ```
:::tip
Client intents are the cornerstone of [intent-based access control (IBAC)](https://otterize.com/ibac).
:::
2. You should quickly see in the **[client-other]** terminal that it times out when calling the server,
   as expected since it didn't declare its intents:
```bash
Calling server...
HTTP/1.1 200 OK
...
hello from /other-client-path  # <- before applying the intents file
# highlight-start
Calling server...              # <- after applying the intents file
RBAC: access denied
Calling server...
RBAC: access denied
# highlight-end
```

3. And in the **[client]** terminal you should see that calls go through, as expected since they were declared:
```bash
Calling server...
HTTP/1.1 200 OK
...
hello from /client-path
```
4. You should also see that a new Istio authorization policy was created:
```bash
kubectl get authorizationpolicies.security.istio.io -n otterize-tutorial-istio
```
This should return:
```
NAME                                                                AGE
authorization-policy-to-nginx-from-client.otterize-tutorial-istio   6s
```

If you've attached Otterize OSS to Otterize Cloud, go back to see the [access graph in your browser](https://app.otterize.com):

![Access graph](/img/quick-tutorials/k8s-istio-authorization-policies/protected.png)

And upon clicking the green arrow:
![Access graph](/img/quick-tutorials/k8s-istio-authorization-policies/protected-edge.png)

It's now clear what happened:
1. The server is now protected, and is also blocking some of its clients. Click on it and go to focus mode, to see what's allowed and how to unblock any blocked clients (if desired).
2. Calls from **[client]** &rarr; **[nginx]** are declared and therefore allowed (solid green arrow).
3. Calls from **[client-other]** &rarr; **[nginx]** are not declared and therefore blocked (dashed red arrow). Click on the arrow to see what to do about it.

:::tip Done!
Otterize did its job of both protecting the server *and* allowing intended access.
:::

## What did we accomplish?

- Controlling access through Istio authorization policies no longer means touching authorization policies at all.

- The server is now protected, and can be accessed only by clients which declared their intents, authenticated via mTLS connection with specific certificates.

- Clients simply declare what they need to access with their intents files.

- The next `kubectl apply` ensures that authorization policies automatically reflect the most recent intended pod-to-pod access.


<details>
<summary>Expand to see what happened behind the scenes</summary>

Otterize generated a specific Istio authorization policy on the ingress of the pod of the server, allowing the server to
be accessed by the pod of the client, based on that client's declared intent. Otterize uses labels to define the authorization policy and associate it
with a server in a namespace, and uses service accounts to identify clients, as Istio requires. This happens as follows:
1. The server's pod is given a label `intents.otterize.com/server` whose value uniquely represents that server.
   The Istio authorization policy stipulates that it applies to the ingress of server pods with this label.
2. The client's service account is looked up through its pod, and used in the policy.
   The authorization policy stipulates that only services with this service account can access the server.
   In the event that the service account is shared by multiple services, an Event is placed on the ClientIntent to warn about this, which is also picked up as a warning in Otterize Cloud, if connected.

Otterize saved us from doing all this work: by simply declaring the client's intents in `intents.yaml`,
all the appropriate configuration was managed automatically behind the scenes.

[Learn more about Istio authorization policies and Otterize](/reference/configuration/intents-operator#istio-authorizationpolicy).
</details>

:::tip Bonus tutorial
Try to create an intents file yourself for **client-other**, and apply it to allow this other client to call the server.
:::

## What's next

- Get started with the [Otterize network mapper for Istio](/quick-tutorials/k8s-istio-watcher) to help you bootstrap intents files with HTTP resources
  for use in [intent-based access control (IBAC)](https://otterize.com/ibac).
- See in advance what calls will be allowed or blocked, by running Otterize in **shadow mode** &mdash; just follow the [quick visual tutorial for IBAC with Istio authorization policies](/quick-visual-tutorials/visual-ibac-istio-authorization-policies).
- Learn how to easily secure Kafka with IBAC, in [a hands-on tutorial](/quick-tutorials/k8s-kafka-mtls) or [a more visual tutorial](/quick-visual-tutorials/visual-ibac-kafka-k8s).


## Teardown

To remove Istio and the deployed examples run:

```bash
helm uninstall istio-base -n istio-system
kubectl delete namespace otterize-tutorial-istio
```
