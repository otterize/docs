---
sidebar_position: 3
title: Deploy mTLS between pods and Kafka
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Kafka + mTLS

This tutorial will walk you through applying intents and deploying mTLS certificates between a client and a Kafka cluster
and configuring intents for one of its clients.
We will:

- Install Otterize
- Learn how to configure [Bitnami's Kafka chart](https://github.com/bitnami/charts/tree/master/bitnami/kafka) to use Otterize-provided mTLS credentials
- Deploy a Kafka cluster
- Learn how to annotate pods for automatic credentials generation
- Deploy a client connecting to Kafka with mTLS
- Apply intents to configure Kafka ACLs
- Inspect the credentials

## Install Otterize
:::note
For this tutorial, we'll disable the network policy component, so that our communications to the Kafka broker don't get blocked -
and we can see the Kafka ACL authorization mechanism in action.
If you already have Otterize installed, redeploy it like so
:::
{@include: ../_common/install-otterize-kafka.md}

## Install Kafka

We will deploy a Kafka cluster using bitnami's [chart](https://github.com/bitnami/charts/tree/master/bitnami/kafka)
To configure the chart to use the Otterize-provided credentials we need to configure it to use SSL
and trust Otterize to configure ACLs:

1. Configure Otterize as a super user to grant it access to configure ACLs
2. Use SSL for its listeners
3. Using pod annotations, tell the SPIRE integration operator how the credentials should be created
4. Authenticate connecting clients using mTLS credentials provided as a K8s secret

<details>
<summary>Expand to see the Helm values.yaml used with the Bitnami chart</summary>


```yaml
{@include: ../../static/code-examples/kafka-mtls/helm/values.yaml}
```
</details>

The following command will deploy a Kafka cluster configured to use Otterize-provided mTLS credentials
with permissions for the intents operator to configure ACLs:
 ```bash
 helm repo add bitnami https://charts.bitnami.com/bitnami
 helm install --create-namespace -n kafka \
   --version 14.x.x \
   -f https://docs.otterize.com/code-examples/kafka-mtls/helm/values.yaml kafka bitnami/kafka
 ```

You can add the `--wait` flag for Helm to wait for deployment to complete and all pods to be Ready, or manually watch for all pods to be `Ready` using `kubectl get pods -n kafka -w`.


## Protect a Kafka topic
Let's protect a single kafka topic (`mytopic`) by applying a `KafkaServerConfig`:
```bash
kubectl apply -f https://docs.otterize.com/code-examples/kafka-mtls/kafkaserverconfig.yaml
```
<details>
<summary>Expand to see the KafkaServerConfig</summary>
<Tabs>

<TabItem value="kafkaserverconfig.yaml" label="kafkaserverconfig.yaml">

```yaml
{@include: ../../static/code-examples/kafka-mtls/kafkaserverconfig.yaml}
```

</TabItem>
</Tabs>
</details>

Upon applying the KafkaServerConfig, an ACL will be configured on Kafka to deny anonymous access to the topic.

```bash
kubectl logs -n kafka statefulset/kafka | grep "Processing Acl change" | grep mytopic | tail -n 1
   ```
You should see the following output:
```
[2022-09-13 10:58:32,052] INFO Processing Acl change notification for ResourcePattern
(resourceType=TOPIC, name=mytopic, patternType=LITERAL), versionedAcls :
Set(User:ANONYMOUS has DENY permission for operations: ALL from hosts: *), zkVersion : 9
(kafka.security.authorizer.AclAuthorizer)
```

## Deploy clients

To generate credentials for the pod we simply need to update the deployment by annotating it.
The required steps are to
1. Annotate the pod; Otterize automatically identifies the `otterize/credentials-secret-name` annotation, generates
mTLS credentials, and stores them as a K8s secret, where the name of the secret is specified by the annotation.
2. Mount the credentials stored as a K8s secret as a volume
3. Mount the volume into the container

<details>
    <summary>Expand to see a detailed example for the configuration</summary>

```yaml
spec:
    template:
        metadata:
        ...
        annotations:
            # highlight-next-line
            otterize/credentials-secret-name: client-credentials-secret       # 1 Generate credentials
    spec:
        volumes:
        # highlight-start
        - name: otterize-credentials
          secret:
            secretName: client-credentials-secret                         # 2 Mount credentials as a volume
        # highlight-end
        containers:
        - name: client
        ...
    volumeMounts:
    # highlight-start
      - name: otterize-credentials
        mountPath: /var/otterize/credentials                          # 3 Mount volume into container
        readOnly: true
    # highlight-end
```
</details>

Our simple example consists of a single client pod and a Kafka broker.

We also apply a KafkaServerConfig to block access to a specific topic unless intents are set
to allow access. At first, we expect the client to be blocked from accessing the specific topic.
We will follow up by applying an intent to allow access.
<details>
<summary>Expand to see the Kubernetes YAMLs used in this example</summary>
<Tabs>

<TabItem value="namespace.yaml" label="namespace.yaml" default>

   ```yaml
   {@include: ../../static/code-examples/kafka-mtls/namespace.yaml}
   ```

</TabItem>

<TabItem value="client-deployment.yaml" label="client-deployment.yaml">

   ```yaml
  {@include: ../../static/code-examples/kafka-mtls/client-deployment.yaml}
  ```

</TabItem>

<TabItem value="client-configmap.yaml" label="client-configmap.yaml">

   ```yaml
  {@include: ../../static/code-examples/kafka-mtls/client-configmap.yaml}
  ```

</TabItem>

</Tabs>
</details>

1. Deploy the client and the Kafka config using `kubectl`.
```bash
kubectl apply -f https://docs.otterize.com/code-examples/kafka-mtls/all.yaml
```

<details>
<summary>Optional: check deployment status</summary>

Check that the `client` pod was deployed:

```bash
kubectl get pods -n otterize-tutorial-kafka-mtls
```
You should see:
```
NAME                      READY   STATUS    RESTARTS   AGE
client-5d9d5c8d7b-7dlzb   1/1     Running   0          24s
```
</details>
2. Let's monitor the client's attempts to access the Kafka topic with a second terminal window,
   so we can see the effects of our changes in real time.

   **Open a second terminal window** and tail the client log:
   ```bash
   kubectl logs -f --tail 1 -n otterize-tutorial-kafka-mtls deploy/myclient
   ```
   At this point the client should log an error saying it is not authorized to access the topic:
   ```
   Loading mTLS certificates
   Connecting to Kafka
   Creating a producer and a consumer for - mytopic
   Sending messages
   time="2022-09-13T10:41:07Z" level=info error="kafka server: The client is not authorized to access this topic"
   Loop exited
   ```

   This is the expected outcome since we configured Kafka to require ACLs for access to this topic.
   Once the client declares its intents, Otterize will add an ACL to Kafka to allow the intended calls.
   Let's see that now...

## Apply intents
1. The client declares its intent to call the server with this `intents.yaml` file:

   ```yaml
   {@include: ../../static/code-examples/kafka-mtls/client-intents.yaml}
   ```
:::tip
Client intents are the cornerstone of [intent-based access control](https://otterize.com/ibac).
:::

   Keep an eye on the logs being tailed in the **second terminal window**
   while you apply this `intents.yaml` file in your **main terminal window** using:
   ```shell
   kubectl apply -f https://docs.otterize.com/code-examples/kafka-mtls/client-intents.yaml
   ```

2. You should quickly see in the **second terminal** that the client is now successfully producing and consuming messages
    ```bash
    Loading mTLS certificates
    Connecting to Kafka
    Creating a producer and a consumer for - mytopic
    Sending messages
    time="2022-09-13T10:41:07Z" level=info error="kafka server: The client is not authorized to access this topic"
    Loop exited                                   <- before applying the intents file
    # highlight-start
    Loading mTLS certificates                     <- after applying the intents file
    Connecting to Kafka
    Creating a producer and a consumer for - mytopic
    Sending messages
    Sent message - Message 1
    Sent message - Message 2
    Sent message - Message 3
    Sent message - Message 4
    Sent message - Message 5
    Read message - Message 1
    Read message - Message 2
    Read message - Message 3
    Read message - Message 4
    Read message - Message 5
   # highlight-end
    ```
3. Observe that an ACL for this client was configured on the Kafka broker:
   ```bash
   kubectl logs -n kafka statefulset/kafka | grep "Processing Acl change" | grep mytopic | tail -n 1
   ```
   You should see
   ```
   [2022-09-13 10:44:52,803] INFO Processing Acl change notification for
   ResourcePattern(resourceType=TOPIC, name=mytopic, patternType=LITERAL), 
   versionedAcls : Set(User:ANONYMOUS has DENY permission for operations: 
   ALL from hosts: *, User:CN=myclient.otterize-tutorial-kafka-mtls,O=SPIRE,C=US has ALLOW permission
   for operations: ALL from hosts: *), zkVersion : 6 (kafka.security.authorizer.AclAuthorizer)
   ```

:::danger Uri: write celebration
TODO
:::

<details>
<summary>Expand to see what happened behind the scenes</summary>

We configured the Kafka helm chart to:
1. Use the SSL protocol for its listeners
2. Annotated its pod to let Otterize know it should generate mTLS credentials in the Java Key Store and Java Trust Store format and store them as a K8s secret.
3. We annotated the client pod to let Otterize know it should generate mTLS credentials in a PEM format.
4. Configured the Kafka broker to use the K8s secret for its credentials.

The Otterize SPIRE integration operator:
1. Created an entry for the annotated client pod with the SPIRE server.
2. Generated matching mTLS credentials using the SPIRE server.
3. Stored the mTLS credentials into a K8s secrets.
4. The secret was mounted into the client pod's container.
5. Configured Kafka to only allow intended access to the specific topic.
6. The client pod connected and authenticated to Kafka using mTLS but couldn't access the topic.
7. We applied intents to allow the client to access the topic.
8. The client pod connected and authenticated to Kafka using mTLS but and accessed the topic successfully.

</details>

## What's next
- Read about how to gradually rollout [secure access for Kafka](/guides/ibac-for-k8s-kafka/) on your existing infrastructure.

## Teardown


:::caution
Take care to remove the intents before removing the KafkaServerConfig or the Kafka broker, as the operator will not know how to remove
the intents if you first make it forget about the Kafka broker or it can't access the broker.
If it's unable to remove the ACLs for the intents, the operator will prevent the intents from being deleted until
it is able to do so.
:::end


To remove the deployed resources run:
```bash
# run this first:
kubectl delete -f https://docs.otterize.com/code-examples/kafka-mtls/client-intents.yaml
# then the rest:
kubectl delete -f https://docs.otterize.com/code-examples/kafka-mtls/all.yaml
kubectl delete -f https://docs.otterize.com/code-examples/kafka-mtls/kafkaserverconfig.yaml
helm uninstall kafka -n kafka
helm repo remove bitnami
```
