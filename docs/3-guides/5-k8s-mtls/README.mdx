---
sidebar_position: 5
title: Kubernetes mTLS with Otterize
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Otterize can automatically provision mTLS credentials by baking exiting K8s workload identities into certificates.

<!-- FIXME
:::note to complete
:::
-->

## Install Otterize
:::note
You can skip this section if Otterize is already installed in your cluster.
:::
{@include: ../../_common/install-otterize.md}

## Choose a Kubernetes cluster and services

You can use this guide with your own set of services, e.g. first in a Kubernetes cluster running dev or lab services,
and eventually in a staging or production cluster. You'll need admin access.

Alternatively, you can deploy our demo setup as follows. You'll deploy these into any Kubernetes cluster to which you have admin access.

### Deploy demo

Our example consists of two pods: client and server communicating over HTTPS using credentials
provisioned by Otterize.

<details>
<summary>Expand to see the details of this example</summary>
<Tabs>

<TabItem value="namespace.yaml" label="namespace.yaml" default>

   ```yaml
   {@include: ../../../static/code-examples/kafka-mtls/namespace.yaml}
   ```

</TabItem>

<TabItem value="client-deployment.yaml" label="client-deployment.yaml">

   ```yaml
  {@include: ../../../static/code-examples/kafka-mtls/client-deployment.yaml}
  ```

</TabItem>

<TabItem value="client-configmap.yaml" label="client-configmap.yaml">

   ```yaml
  {@include: ../../../static/code-examples/kafka-mtls/client-configmap.yaml}
  ```

</TabItem>
<TabItem value="client.js" label="client.js" default>

   ```js
   const fs = require('fs');
const https = require('https');

const options = {
    hostname: 'server.otterize-tutorial-mtls',
    port: 443,
    path: '/hello',
    method: 'GET',
    cert: fs.readFileSync('/var/otterize/credentials/svid.pem'),
    key: fs.readFileSync('/var/otterize/credentials/key.pem'),
    ca: fs.readFileSync('/var/otterize/credentials/bundle.pem')
}

const req = https.request(
    options,
    res => {
        res.on('data', function (data) {
            console.log(data.toString())
        });
    }
);

req.end();
   ```

</TabItem>
<TabItem value="server.js" label="server.js" default>

   ```js
const https = require(`https`);
const fs = require(`fs`);

const options = {
  key: fs.readFileSync('/var/otterize/credentials/key.pem'),
  cert: fs.readFileSync('/var/otterize/credentials/svid.pem'),
  ca: fs.readFileSync('/var/otterize/credentials/bundle.pem'),
  requestCert: true
};

https.createServer(
    options,
    (req, res) => {
        const peerCert = req.connection.getPeerCertificate();
        const ownCert = req.connection.getCertificate();
        console.log("Received request:");
        console.log(peerCert.subject.CN + ":\t" + req.method + " " + req.url);
        if (req.url === '/hello') {
            res.writeHead(200);
            res.end('mTLS hello world\nfrom: ' + ownCert.subject.CN + '\nto client: ' + peerCert.subject.CN);
        } else {
            res.end();
        }
    }).listen(443);
   ```

</TabItem>
</Tabs>
</details>



Deploy the `client` and `server` using `kubectl`.
   ```bash
   kubectl apply -f https://docs.otterize.com/code-examples/mtls/all.yaml
   ```

<details>
<summary>Optional: check deployment status</summary>

```bash
kubectl get pods -n otterize-tutorial-mtls
```
You should see
```
NAME                      READY   STATUS    RESTARTS   AGE
client-5689997b5c-grlnt   1/1     Running   0          35s
server-6698c58cbc-v9n9b   1/1     Running   0          34s
```
</details>

## Annotate deployment
To generate credentials for the pod we simply need to update the deployment by annotating it.
The required steps are to
1. Annotate the pod - Otterize automatically identifies the `otterize/credentials-secret-name` annotation, generates
mTLS credentials, and stores them as K8s secret named as the annotation value.
2. Mount the credentials stored as a K8s secret as a volume
3. Mount the volume into the container

<details>
<summary>Expand to see a detailed explanation for the annotations</summary>

```yaml
spec:
  template:
    metadata:
      ...
      annotations:
        # highlight-next-line
        otterize/credentials-secret-name: client-credentials-secret       # 1 Generate credentials
    spec:
      volumes:
        # highlight-start
        - name: otterize-credentials
          secret:
            secretName: client-credentials-secret                         # 2 Mount credentials as a volume
            # highlight-end
      containers:
        - name: client
        ...
        volumeMounts:
          # highlight-start
          - name: otterize-credentials
            mountPath: /var/otterize/credentials                          # 3 Mount volume into container
            readOnly: true
            # highlight-end
```
</details>

The provided demo pods were already configured and annotated as required.

### Annotation parameters
The following annotations control different aspects of the credential generation:

#### Global parameters
- `spire-integration.otterize.com/tls-secret-name`  - The name of the k8s secret in which the certificate data is stored
- `spire-integration.otterize.com/dns-names` - A comma-separated list of additional dns names to be registered as part of the
- `spire-integration.otterize.com/cert-ttl` - The certificate TTL. Defaults to SPIRE-server's configured default TTL
:::note
Otterize defaults to generating credentials with an expiry time of 1 day. The certificates are
automatically refreshed before expiring, and you must take care to always read the credentials from file, rather than caching them for this reason.

To set a longer expiration time, set the `spire-integration.otterize.com/cert-ttl` annotation for your pods. FIXME For more information, see the documentation for the [SPIRE Integration Operator](/components/spire-integration-operator)
:::
- `spire-integration.otterize.com/cert-type` - The requested certificate type - pem (default) or jks

#### Cert-type - pem parameters
- `spire-integration.otterize.com/svid-file-name` - The name of the file in the secret data, that stores the certificate's SVID file. Defaults to `svid.pem`
- `spire-integration.otterize.com/bundle-file-name` - The name of the file in the secret data, that stores the certificate's bundle file. Defaults to `bundle.pem`.
- `spire-integration.otterize.com/key-file-name` - The name of the file in the secret data, that stores the certificate's key file. Defaults to `key.pem`.

#### Cert-type - jks parameters
- `spire-integration.otterize.com/keystore-file-name` - The name of the file in the secret data, that stores the certificate's key store file. Defaults to `keystore.jks`.
- `spire-integration.otterize.com/truststore-file-name` - The name of the file in the secret data, that stores the certificate's trust store file. Defaults to `truststore.jks`.
- `spire-integration.otterize.com/jks-password` - The jks certificate password. Defaults to `password`.

:::tip
Certificates are automatically refreshed before expiring. We recommend loading certificates each time before using them where possible.
:::

## Verify generated credentials

### Inspect credentials

We can use openssl to inspect the generated certificates. The certificates are stored as `K8s secrets` and are also
`mounted` into containers.

We will first retrieve them with one of the following options

   <Tabs>
     <TabItem value="secret-direct" label="K8s secret" default>
   To retrieve the credentials from the K8s secrets store use:

   ```shell
   kubectl get secret -n otterize-tutorial-mtls client-credentials-secret -o jsonpath='{.data.svid\.pem}' | base64 -d > svid.pem
   ```
   </TabItem>
   <TabItem value="secret-pod" label="K8s pod mount" default>
   To retrieve the credentials from the container mount use:

   ```shell
   kubectl exec -n otterize-tutorial-mtls -it deploy/client -- cat /var/otterize/credentials/svid.pem > svid.pem
   ```

   </TabItem>
   </Tabs>

And then inspect them with

   ```shell
   openssl x509 -in svid.pem -text | head -n 15
   ```
   You should see a similar output to
   ```x509
   Certificate:
       Data:
           Version: 3 (0x2)
           Serial Number:
               0b:eb:eb:4d:0e:02:7e:28:93:30:1c:55:26:22:8b:c7
           Signature Algorithm: sha256WithRSAEncryption
           Issuer: C = US, O = SPIRE
           Validity
               Not Before: Aug 24 12:19:57 2022 GMT
               Not After : Sep 23 12:20:07 2022 GMT
   # highlight-next-line
           Subject: C = US, O = SPIRE, CN = client.otterize-tutorial-mtls       # the client's name
           Subject Public Key Info:
               Public Key Algorithm: id-ecPublicKey
                   Public-Key: (256 bit)
                   pub:
   ```

You can see that Otterize generated an X.509 keypair using the pod's name `client` and namespace `otterize-tutorial-mtls`: `client.otterize-tutorial-mtls`.
The certificate belongs to a chain of trust starting at the SPIRE server.


### Optional - verify demo setup

Confirm that the client can successfully call the server using HTTP over mTLS. The client makes requests, and the server replies
with the server's certificate's `common name` as well as the `client`'s certificate `common name`.

   ```bash
   kubectl logs --tail 3 -n otterize-tutorial-mtls deploy/client
   ```

   You should see the following line

   ```shell
   mTLS hello world
   from: server.otterize-tutorial-mtls          # server's common name in the certificate
   to client: client.otterize-tutorial-mtls     # client's common name in the certificate
   ```
You can also follow the server's output log with
   ```bash
   kubectl logs --tail 1 -n otterize-tutorial-mtls deploy/server
   ```

   You should see the following line

   ```shell
   client.otterize-tutorial-mtls:  GET /hello
   ```


#### What happened behind the scenes

1. We annotated the pods to let Otterize know it should generate mTLS credentials.
2. The Otterize SPIRE integration operator
    1. Created an entries for the annotated pods with the SPIRE server.
    2. Generated matching mTLS credentials using the SPIRE server.
    3. Stored the mTLS credentials into a K8s secrets.
3. The secrets were mounted (separately) into each pod's container.
4. The pods communicated with each other using HTTP of mutual TLS.

## What's next

- Learn how to configure your existing code to use mTLS for [HTTPS](/service-identities/using-credentials/#http)
(clients and servers) and for [Kafka clients](/service-identities/using-credentials/#kafka).
- Configure secure access between pods and Kafka with this [guide](/guides/ibac-for-k8s-kafka/).