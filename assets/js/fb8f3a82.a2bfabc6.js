"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8263],{5680:(e,t,n)=>{n.d(t,{xA:()=>u,yg:()=>h});var r=n(6540);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=o,h=d["".concat(l,".").concat(m)]||d[m]||p[m]||i;return n?r.createElement(h,a(a({ref:t},u),{},{components:n})):r.createElement(h,a({ref:t},u))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:o,a[1]=s;for(var c=2;c<i;c++)a[c]=n[c];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5679:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var r=n(8168),o=(n(6540),n(5680));const i={sidebar_position:7,title:"Terminology"},a=void 0,s={unversionedId:"reference/terminology/README",id:"reference/terminology/README",title:"Terminology",description:"An overview of the terminology used in Otterize OSS documentation.",source:"@site/docs/reference/terminology/README.mdx",sourceDirName:"reference/terminology",slug:"/reference/terminology/",permalink:"/reference/terminology/",draft:!1,editUrl:"https://github.com/otterize/docs/edit/main/docs/reference/terminology/README.mdx",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7,title:"Terminology"},sidebar:"docSidebar",previous:{title:"Differences between v1 and v2",permalink:"/reference/ClientIntents CRD/migrateToV2"},next:{title:"Kubernetes mTLS",permalink:"/reference/mtls/"}},l={},c=[{value:"Basics",id:"basics",level:2},{value:"Workload",id:"workload",level:3},{value:"Service",id:"service",level:3},{value:"Resource",id:"resource",level:3},{value:"CLI",id:"cli",level:3},{value:"Intent (or client intent)",id:"intent-or-client-intent",level:3},{value:"Integrations",id:"integrations",level:3},{value:"Identity",id:"identity",level:2},{value:"PKI",id:"pki",level:3},{value:"mTLS",id:"mtls",level:3},{value:"SPIRE",id:"spire",level:3},{value:"Credentials operator",id:"credentials-operator",level:3},{value:"Enforcement",id:"enforcement",level:2},{value:"Network policies",id:"network-policies",level:3},{value:"Kafka ACLs",id:"kafka-acls",level:3},{value:"Kubernetes",id:"kubernetes",level:2},{value:"Custom resource",id:"custom-resource",level:3},{value:"CNI (Container Network Interface)",id:"cni-container-network-interface",level:3},{value:"Namespaces and Environments",id:"namespaces-and-environments",level:3},{value:"Clusters",id:"clusters",level:3}],u={toc:c},d="wrapper";function p(e){let{components:t,...n}=e;return(0,o.yg)(d,(0,r.A)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.yg)("p",null,"An overview of the terminology used in Otterize OSS documentation.\nIf you think a term is missing here, please ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/otterize/docs/issues/new"},"let us know"),"."),(0,o.yg)("h2",{id:"basics"},"Basics"),(0,o.yg)("h3",{id:"workload"},"Workload"),(0,o.yg)("p",null,"An Otterize workload is the logical workload identity used to refer to a particular service. For example, Kafka is a workload, the Frontend is a workload, the login-service is a workload. But an S3 bucket is not a workload."),(0,o.yg)("p",null,"It can be a client or a server or both. Workloads are connected through client intents: one workload intends to call another workload. ",(0,o.yg)("a",{parentName:"p",href:"/reference/workload-identities"},"Learn how workload identity resolution happens"),"."),(0,o.yg)("h3",{id:"service"},"Service"),(0,o.yg)("p",null,"A Service refers to a Kubernetes Service. This is different from a Workload, which is a logical entity that exists in Otterize and can be a client or a server. A Service is a Kubernetes object that exposes a set of pods as a network service. ",(0,o.yg)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/services-networking/service/"},"Read more about Kubernetes Services in the official documentation"),"."),(0,o.yg)("h3",{id:"resource"},"Resource"),(0,o.yg)("p",null,"A resource is a generic term used to refer to any entity that can be accessed or interacted with that is not a workload. In the context of Otterize, resources can be databases, Kafka topics, S3 buckets."),(0,o.yg)("h3",{id:"cli"},"CLI"),(0,o.yg)("p",null,"The ",(0,o.yg)("a",{parentName:"p",href:"/reference/cli"},"Otterize CLI")," is a command-line utility used to control and interact with the Otterize network mapper, manipulate local Intents files, and interact with Otterize Cloud."),(0,o.yg)("h3",{id:"intent-or-client-intent"},"Intent (or client intent)"),(0,o.yg)("p",null,"Otterize intents are a way to declare that one workload intends to call another workload or use a resource. Otterize uses them to compute which credentials and policies are required to enable the calls to go through, and block any unintended calls. An ",(0,o.yg)("em",{parentName:"p"},"intent")," refers to a client declaring a particular call to a server; ",(0,o.yg)("em",{parentName:"p"},"all")," a given client's intents to the servers it intends to call are collected in a single ",(0,o.yg)("em",{parentName:"p"},"client intents file"),". ",(0,o.yg)("a",{parentName:"p",href:"/overview/intent-based-access-control"},"Learn more about intents"),"."),(0,o.yg)("h3",{id:"integrations"},"Integrations"),(0,o.yg)("p",null,"An Integration is how you configure Otterize Cloud to work with your infrastructure. For example, you can configure Otterize Cloud to work with a Kubernetes cluster, your GitHub organization, your AWS account, your Slack organization, etc."),(0,o.yg)("p",null,"Each Integration has different steps that you need to complete to perform the integration. For example, a Kubernetes integration requires that you deploy the Otterize operators. A GitHub integration requires that you connect the Otterize GitHub app to the relevant repositories."),(0,o.yg)("h2",{id:"identity"},"Identity"),(0,o.yg)("h3",{id:"pki"},"PKI"),(0,o.yg)("p",null,"PKI stands for public key infrastructure, and refers to the infrastructure used to provision X.509 credentials.\nA common use case for PKI is to support mTLS."),(0,o.yg)("h3",{id:"mtls"},"mTLS"),(0,o.yg)("p",null,"mTLS stands for mutual TLS, and is a form of TLS where both the client and server mutually authenticate to each other.\nIn other words, mTLS is mutual TLS."),(0,o.yg)("p",null,"In regular TLS, only the server is authenticated. For example, when you connect to google.com, a\nnd your browser authenticates google.com using its certificate, you're using TLS;\nbut google.com does not authenticate you, as the client, with a certificate, so the communication isn't using mTLS, just TLS."),(0,o.yg)("h3",{id:"spire"},"SPIRE"),(0,o.yg)("p",null,"An open-source implementation of the ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/spiffe/spire"},"SPIFFE")," specification. It's used for workload attestation and credential management. ",(0,o.yg)("a",{parentName:"p",href:"https://spiffe.io/docs/latest/spire-about/"},"Read more about SPIRE in the official documentation"),"."),(0,o.yg)("h3",{id:"credentials-operator"},"Credentials operator"),(0,o.yg)("p",null,"The Otterize ",(0,o.yg)("a",{parentName:"p",href:"/reference/credentials-operator"},"credentials operator")," automatically resolves pods to dev-friendly workload identities, registers them with a SPIRE server or with the Otterize Cloud-managed credentials service, and provisions credentials as Kubernetes Secrets."),(0,o.yg)("h2",{id:"enforcement"},"Enforcement"),(0,o.yg)("h3",{id:"network-policies"},"Network policies"),(0,o.yg)("p",null,"Kubernetes network policies can be used to control network access between pods in a Kubernetes cluster.\nTo do so they require the installation of a Kubernetes CNI network plugin that supports network policy enforcement.\nOne commonly supported CNI is Calico.\n",(0,o.yg)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/services-networking/network-policies/"},"Read more about network policies in the official documentation"),"."),(0,o.yg)("h3",{id:"kafka-acls"},"Kafka ACLs"),(0,o.yg)("p",null,"ACLs stand for Access Control Lists, a built-in mechanism in Kafka (and other systems) for authorizing access\nto Kafka resources such as topics.\n",(0,o.yg)("a",{parentName:"p",href:"https://docs.confluent.io/platform/current/kafka/authorization.html#authorization-using-acls"},"Read more about Kafka ACLs in the official documentation"),"."),(0,o.yg)("h2",{id:"kubernetes"},"Kubernetes"),(0,o.yg)("h3",{id:"custom-resource"},"Custom resource"),(0,o.yg)("p",null,"A Kubernetes custom resource refers to a resource that is not present in the base distribution of Kubernetes (such as Deployment or Pod), but comes with an installed operator. The ",(0,o.yg)("a",{parentName:"p",href:"/overview/intent-based-access-control"},"Otterize ClientIntents")," are one such resource. ",(0,o.yg)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/"},"Read more about Kubernetes custom resources here"),"."),(0,o.yg)("h3",{id:"cni-container-network-interface"},"CNI (Container Network Interface)"),(0,o.yg)("p",null,"CNI is a CNCF project that provides libraries for implementing plugins for configuring network interfaces in Linux containers, and is used by Kubernetes to provide pods running in a cluster with network connectivity.\nExamples of CNI plugins are Calico, Cilium, the AWS VPC CNI plugin. ",(0,o.yg)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/"},"Read more about Kubernetes CNI plugins here"),"."),(0,o.yg)("h3",{id:"namespaces-and-environments"},"Namespaces and Environments"),(0,o.yg)("p",null,"Namespaces are used to group related services within a Kubernetes cluster and can be mapped to different environments (e.g., dev, staging, production). Intents can be cross-namespace and cross-environment, and Otterize Cloud associates namespaces with their respective environments. Environment names must be unique within an organization."),(0,o.yg)("h3",{id:"clusters"},"Clusters"),(0,o.yg)("p",null,"A Kubernetes cluster connected to Otterize Cloud is represented by a cluster object in the cloud. This object contains information about the cluster's intents, services, credentials, and configuration. Multiple clusters and namespaces can belong to a single environment, or environments can span multiple clusters, depending on the organization's needs. Cluster names must be unique within an organization."))}p.isMDXComponent=!0}}]);