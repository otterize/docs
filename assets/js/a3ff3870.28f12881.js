"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8595],{5680:(e,n,i)=>{i.d(n,{xA:()=>p,yg:()=>y});var t=i(6540);function r(e,n,i){return n in e?Object.defineProperty(e,n,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[n]=i,e}function a(e,n){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),i.push.apply(i,t)}return i}function o(e){for(var n=1;n<arguments.length;n++){var i=null!=arguments[n]?arguments[n]:{};n%2?a(Object(i),!0).forEach((function(n){r(e,n,i[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):a(Object(i)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(i,n))}))}return e}function s(e,n){if(null==e)return{};var i,t,r=function(e,n){if(null==e)return{};var i,t,r={},a=Object.keys(e);for(t=0;t<a.length;t++)i=a[t],n.indexOf(i)>=0||(r[i]=e[i]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(t=0;t<a.length;t++)i=a[t],n.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(r[i]=e[i])}return r}var c=t.createContext({}),l=function(e){var n=t.useContext(c),i=n;return e&&(i="function"==typeof e?e(n):o(o({},n),e)),i},p=function(e){var n=l(e.components);return t.createElement(c.Provider,{value:n},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},u=t.forwardRef((function(e,n){var i=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=l(i),u=r,y=d["".concat(c,".").concat(u)]||d[u]||m[u]||a;return i?t.createElement(y,o(o({ref:n},p),{},{components:i})):t.createElement(y,o({ref:n},p))}));function y(e,n){var i=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=i.length,o=new Array(a);o[0]=u;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s[d]="string"==typeof e?e:r,o[1]=s;for(var l=2;l<a;l++)o[l]=i[l];return t.createElement.apply(null,o)}return t.createElement.apply(null,i)}u.displayName="MDXCreateElement"},4616:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var t=i(8168),r=(i(6540),i(5680));const a={sidebar_position:5,title:"Service identities and resolution"},o=void 0,s={unversionedId:"reference/service-identities/README",id:"reference/service-identities/README",title:"Service identities and resolution",description:"Otterize supports two approaches for specifying service identities in Kubernetes: explicit and implicit.",source:"@site/docs/reference/service-identities/README.mdx",sourceDirName:"reference/service-identities",slug:"/reference/service-identities/",permalink:"/reference/service-identities/",draft:!1,editUrl:"https://github.com/otterize/docs/edit/main/docs/reference/service-identities/README.mdx",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,title:"Service identities and resolution"},sidebar:"docSidebar",previous:{title:"API",permalink:"/reference/api/"},next:{title:"Troubleshooting",permalink:"/reference/troubleshooting/"}},c={},l=[{value:"Explicitly specifying <code>Kind</code>",id:"explicitly-specifying-kind",level:2},{value:"Implicit Specification",id:"implicit-specification",level:2},{value:"Kubernetes service identity resolution",id:"kubernetes-service-identity-resolution",level:3}],p={toc:l},d="wrapper";function m(e){let{components:n,...i}=e;return(0,r.yg)(d,(0,t.A)({},p,i,{components:n,mdxType:"MDXLayout"}),(0,r.yg)("p",null,"Otterize supports two approaches for specifying service identities in Kubernetes: explicit and implicit."),(0,r.yg)("h2",{id:"explicitly-specifying-kind"},"Explicitly specifying ",(0,r.yg)("inlineCode",{parentName:"h2"},"Kind")),(0,r.yg)("p",null,"This approach requires specifying both the name, possibly with a namespace, and the kind of the service in the intent, ensuring precise identification."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-yaml"},"   apiVersion: k8s.otterize.com/v1alpha3\n   kind: ClientIntents\n   metadata:\n     name: client\n     namespace: otterize-tutorial-istio-mapping\n   spec:\n     service:\n       name: client\n       kind: Deployment\n     calls:\n       - name: server.example-ns\n         kind: Service\n")),(0,r.yg)("p",null,"In the YAML above, the service ",(0,r.yg)("inlineCode",{parentName:"p"},"client")," is a ",(0,r.yg)("inlineCode",{parentName:"p"},"Deployment")," in the namespace ",(0,r.yg)("inlineCode",{parentName:"p"},"otterize-tutorial-istio-mapping"),", and it intends to call the service ",(0,r.yg)("inlineCode",{parentName:"p"},"server")," is a ",(0,r.yg)("inlineCode",{parentName:"p"},"Service")," in the namespace ",(0,r.yg)("inlineCode",{parentName:"p"},"example-ns"),"."),(0,r.yg)("h2",{id:"implicit-specification"},"Implicit Specification"),(0,r.yg)("p",null,"This approach requires only the service name to be specified in the intent. When using the implicit approach, Otterize employs an ",(0,r.yg)("a",{parentName:"p",href:"/reference/service-identities#kubernetes-service-identity-resolution"},"identity resolution algorithm")," to determine the service kind."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-yaml"},"   apiVersion: k8s.otterize.com/v1alpha3\n   kind: ClientIntents\n   metadata:\n     name: client\n     namespace: otterize-tutorial-istio-mapping\n   spec:\n     service:\n       name: client\n     calls:\n       - name: server.example-ns\n")),(0,r.yg)("p",null,"In the YAML above, both services has no kind specified. Otterize will resolve the kind of the service based on the identity resolution algorithm.\nPay attention that by not specifying the kind, the identity resolution algorithm will not use the kubernetes kind:",(0,r.yg)("inlineCode",{parentName:"p"},"Service")," but will use the kind of the resource that owns the pod."),(0,r.yg)("h3",{id:"kubernetes-service-identity-resolution"},"Kubernetes service identity resolution"),(0,r.yg)("p",null,"How do Otterize operators decide what is the name of the service that runs within the pod? The algorithm is as follows:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"If the pod has an ",(0,r.yg)("inlineCode",{parentName:"li"},"intents.otterize.com/service-name")," annotation, its value is used as the service name. (You can change which annotation is used by setting ",(0,r.yg)("inlineCode",{parentName:"li"},"global.serviceNameOverrideAnnotationName")," ","\u2014"," see the ",(0,r.yg)("a",{parentName:"li",href:"/reference/configuration/otterize-chart#global-parameters"},"docs"),".) This allows developers and\nautomations to explicitly name services, if needed. The value must not contain a period ",(0,r.yg)("inlineCode",{parentName:"li"},".")," as a period is used to separate service name and namespace, when the service is from a different namespace: ",(0,r.yg)("inlineCode",{parentName:"li"},"svcname.namespace"),"."),(0,r.yg)("li",{parentName:"ol"},"If there is no ",(0,r.yg)("inlineCode",{parentName:"li"},"intents.otterize.com/service-name")," annotation, a recursive look-up is performed for the Kubernetes resource owner of\nthe pod, until the root resource is reached, and its name is used as the service name. For example, if you have\na ",(0,r.yg)("inlineCode",{parentName:"li"},"Deployment")," named ",(0,r.yg)("inlineCode",{parentName:"li"},"checkoutservice"),", which then creates and owns a ",(0,r.yg)("inlineCode",{parentName:"li"},"ReplicaSet"),", which then creates and owns\na ",(0,r.yg)("inlineCode",{parentName:"li"},"Pod"),", then the service name for that pod is ",(0,r.yg)("inlineCode",{parentName:"li"},"checkoutservice")," - same as the name of the ",(0,r.yg)("inlineCode",{parentName:"li"},"Deployment"),'. This is\nintended to capture the likely-more-meaningful "human name" of the service. If the resulting service name contains\na period ',(0,r.yg)("inlineCode",{parentName:"li"},"."),", it is replaced with an underscore ",(0,r.yg)("inlineCode",{parentName:"li"},"_"),". Periods are used in service names to denote namespaces, e.g. ",(0,r.yg)("inlineCode",{parentName:"li"},"svcname.namespace"),".")))}m.isMDXComponent=!0}}]);