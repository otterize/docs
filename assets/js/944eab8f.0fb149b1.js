"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8626],{5680:(e,t,n)=>{n.d(t,{xA:()=>l,yg:()=>u});var r=n(6540);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=r.createContext({}),p=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},l=function(e){var t=p(e.components);return r.createElement(c.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),d=p(n),h=o,u=d["".concat(c,".").concat(h)]||d[h]||m[h]||a;return n?r.createElement(u,i(i({ref:t},l),{},{components:n})):r.createElement(u,i({ref:t},l))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=h;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[d]="string"==typeof e?e:o,i[1]=s;for(var p=2;p<a;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},7115:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>p});var r=n(8168),o=(n(6540),n(5680));const a={sidebar_position:4,title:"Network mapper"},i=void 0,s={unversionedId:"reference/configuration/network-mapper/README",id:"reference/configuration/network-mapper/README",title:"Network mapper",description:"The Otterize network mapper creates a map of in-cluster traffic by (1) capturing DNS traffic and (2) inspecting active connections in the same manner netstat does, then resolving the IP addresses participating in connections to the Pods, and crawling up the ownership of the Pod until it reaches the root object. See Service identities to learn more on how service name resolving happens. The network mapper continues building the network map as long as it's deployed.",source:"@site/docs/reference/configuration/network-mapper/README.mdx",sourceDirName:"reference/configuration/network-mapper",slug:"/reference/configuration/network-mapper/",permalink:"/reference/configuration/network-mapper/",draft:!1,editUrl:"https://github.com/otterize/docs/edit/main/docs/reference/configuration/network-mapper/README.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,title:"Network mapper"},sidebar:"docSidebar",previous:{title:"Helm chart",permalink:"/reference/configuration/credentials-operator/helm-chart"},next:{title:"Helm chart",permalink:"/reference/configuration/network-mapper/helm-chart"}},c={},p=[{value:"How does the network mapper work?",id:"how-does-the-network-mapper-work",level:2},{value:"Components",id:"components",level:3},{value:"DNS responses",id:"dns-responses",level:3},{value:"Active TCP connections",id:"active-tcp-connections",level:3},{value:"Kafka logs",id:"kafka-logs",level:3},{value:"Istio sidecar metrics",id:"istio-sidecar-metrics",level:3},{value:"Deploying the network mapper",id:"deploying-the-network-mapper",level:2},{value:"Monitoring the network mapper",id:"monitoring-the-network-mapper",level:2},{value:"Pod annotations",id:"pod-annotations",level:2}],l={toc:p},d="wrapper";function m(e){let{components:t,...n}=e;return(0,o.yg)(d,(0,r.A)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,o.yg)("p",null,"The Otterize network mapper creates a map of in-cluster traffic by (1) capturing DNS traffic and (2) inspecting active connections in the same manner ",(0,o.yg)("inlineCode",{parentName:"p"},"netstat")," does, then resolving the IP addresses participating in connections to the Pods, and crawling up the ownership of the Pod until it reaches the root object. See ",(0,o.yg)("a",{parentName:"p",href:"/reference/service-identities"},"Service identities")," to learn more on how service name resolving happens. The network mapper continues building the network map as long as it's deployed."),(0,o.yg)("p",null,"You can then use the Otterize CLI to list the traffic by client, reset the traffic the mapper remembers, or export it as JSON or YAML, which serves as ClientIntents Kubernetes resources). ClientIntents can be consumed by the ",(0,o.yg)("a",{parentName:"p",href:"/reference/configuration/intents-operator"},"Otterize intents operator")," to apply network policies\nor Kafka ACLs to your cluster, implementing ",(0,o.yg)("a",{parentName:"p",href:"/intent-based-access-control"},"intent-based access control"),"."),(0,o.yg)("p",null,"To get started, follow the ",(0,o.yg)("a",{parentName:"p",href:"/quickstart/visualization/k8s-network-mapper"},"quick hands-on tutorial"),"."),(0,o.yg)("p",null,"The network mapper also supports exporting Grafana Tempo-style metrics, contributed by the community. See the ",(0,o.yg)("a",{parentName:"p",href:"/reference/configuration/network-mapper/helm-chart#opentelemetry-exporter-parameters"},"Helm chart documentation's OpenTelemetry section")," to learn how to enable this feature."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-shell"},"cartservice in namespace otterize-ecom-demo calls:\n - redis-cart\ncheckoutservice in namespace otterize-ecom-demo calls:\n - cartservice\n - currencyservice\n - emailservice\n - paymentservice\n - productcatalogservice\n - shippingservice\nfrontend in namespace otterize-ecom-demo calls:\n - adservice\n - cartservice\n - checkoutservice\n - currencyservice\n - productcatalogservice\n - recommendationservice\n - shippingservice\nloadgenerator in namespace otterize-ecom-demo calls:\n - frontend\nrecommendationservice in namespace otterize-ecom-demo calls:\n - productcatalogservice\n")),(0,o.yg)("h2",{id:"how-does-the-network-mapper-work"},"How does the network mapper work?"),(0,o.yg)("h3",{id:"components"},"Components"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Mapper - the mapper is deployed once per cluster, and receives traffic information from the sniffer and watchers, and resolves the information to communications between (service identities)","[/service-identities]","."),(0,o.yg)("li",{parentName:"ul"},"Sniffer - the sniffer is deployed to each node using a DaemonSet, and is responsible for capturing node-local DNS traffic and inspecting open connections."),(0,o.yg)("li",{parentName:"ul"},"Kafka watcher (",(0,o.yg)("strong",{parentName:"li"},"beta"),") - the Kafka watcher is deployed once per cluster and is responsible for detecting accesses to Kafka topics, which services perform those accesses and which operations they use."),(0,o.yg)("li",{parentName:"ul"},"Istio watcher (",(0,o.yg)("strong",{parentName:"li"},"beta"),") - the Istio watcher is deployed once per cluster and queries Istio Envoy sidecars for HTTP traffic statistics, which are used to detect HTTP traffic with paths. Currently, the Istio watcher has a limitation where it reports all HTTP traffic seen by the sidecar since it was started, regardless of when it was seen.")),(0,o.yg)("h3",{id:"dns-responses"},"DNS responses"),(0,o.yg)("p",null,"DNS is a common network protocol used for service discovery. When a pod (",(0,o.yg)("inlineCode",{parentName:"p"},"checkoutservice"),") tries to connect to a Kubernetes service\n(",(0,o.yg)("inlineCode",{parentName:"p"},"orderservice"),") or another pod, a DNS query is sent out. The network mapper watches DNS responses and extracts the IP addresses, which are used for the ",(0,o.yg)("a",{parentName:"p",href:"/reference/service-identities"},"service identity resolving process"),"."),(0,o.yg)("h3",{id:"active-tcp-connections"},"Active TCP connections"),(0,o.yg)("p",null,"DNS responses will only appear when new connections are opened. To handle long-lived connections, the network mapper also queries open TCP connections in a manner similar to ",(0,o.yg)("inlineCode",{parentName:"p"},"netstat")," or ",(0,o.yg)("inlineCode",{parentName:"p"},"ss"),". The IP addresses are used for the ",(0,o.yg)("a",{parentName:"p",href:"/reference/service-identities"},"service identity resolving process"),", as above."),(0,o.yg)("h3",{id:"kafka-logs"},"Kafka logs"),(0,o.yg)("p",null,"The Kafka watcher periodically examines logs of Kafka servers provided by the user through configuration, parses them and deduces topic-level access to Kafka from pods in the cluster.\nThe watcher is only able to parse Kafka logs when Kafka servers' Authorizer logger is configured to output logs to ",(0,o.yg)("inlineCode",{parentName:"p"},"stdout")," with ",(0,o.yg)("inlineCode",{parentName:"p"},"DEBUG")," level."),(0,o.yg)("h3",{id:"istio-sidecar-metrics"},"Istio sidecar metrics"),(0,o.yg)("p",null,"The Istio watcher periodically queries for all pods with the ",(0,o.yg)("inlineCode",{parentName:"p"},"security.istio.io/tlsMode")," label, queries each pod's Istio sidecar for metrics about connections, and deduces connections with HTTP paths between pods covered by the Istio service mesh."),(0,o.yg)("h2",{id:"deploying-the-network-mapper"},"Deploying the network mapper"),(0,o.yg)("p",null,"To deploy the network mapper, ",(0,o.yg)("a",{parentName:"p",href:"/reference/configuration/network-mapper/helm-chart"},"use the Helm chart"),"."),(0,o.yg)("h2",{id:"monitoring-the-network-mapper"},"Monitoring the network mapper"),(0,o.yg)("p",null,"All network mapper pods expose a Prometheus metrics endpoint on port 2112, on ",(0,o.yg)("inlineCode",{parentName:"p"},"/metrics"),"."),(0,o.yg)("h2",{id:"pod-annotations"},"Pod annotations"),(0,o.yg)("p",null,"You can override the service name the network mapper uses when it computes the service name using a pod annotation."),(0,o.yg)("table",null,(0,o.yg)("thead",{parentName:"table"},(0,o.yg)("tr",{parentName:"thead"},(0,o.yg)("th",{parentName:"tr",align:null},"Annotation"),(0,o.yg)("th",{parentName:"tr",align:null},"Description"))),(0,o.yg)("tbody",{parentName:"table"},(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("inlineCode",{parentName:"td"},"intents.otterize.com/service-name")),(0,o.yg)("td",{parentName:"tr",align:null},"Used for ",(0,o.yg)("a",{parentName:"td",href:"/reference/service-identities#kubernetes-service-identity-resolution"},"service identity resolution"),".")))))}m.isMDXComponent=!0}}]);