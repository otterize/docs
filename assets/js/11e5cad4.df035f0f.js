"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6406],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=c(n),h=a,m=u["".concat(l,".").concat(h)]||u[h]||p[h]||i;return n?r.createElement(m,o(o({ref:t},d),{},{components:n})):r.createElement(m,o({ref:t},d))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:a,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},9711:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var r=n(7462),a=(n(7294),n(3905));const i={sidebar_position:1,title:"Object model"},o=void 0,s={unversionedId:"otterize-cloud/object-model",id:"otterize-cloud/object-model",title:"Object model",description:"In Otterize Cloud, as across all of the Otterize product, the central object is the intent. Intent-based access control (IBAC) bases the authorization model of a server on the set of calls its clients declare they intend to make, granting them access to make declared calls, while blocking undeclared calls.",source:"@site/docs/otterize-cloud/object-model.mdx",sourceDirName:"otterize-cloud",slug:"/otterize-cloud/object-model",permalink:"/otterize-cloud/object-model",draft:!1,editUrl:"https://github.com/otterize/docs/edit/main/docs/otterize-cloud/object-model.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Object model"},sidebar:"docSidebar",previous:{title:"Otterize Cloud",permalink:"/otterize-cloud/"},next:{title:"Otterize OSS Helm chart",permalink:"/reference/configuration/otterize-chart/"}},l={},c=[{value:"Intents",id:"intents",level:2},{value:"Services",id:"services",level:2},{value:"Namespaces and environments",id:"namespaces-and-environments",level:2},{value:"Integrations",id:"integrations",level:2}],d={toc:c},u="wrapper";function p(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"In Otterize Cloud, as across all of the Otterize product, the central object is the ",(0,a.kt)("strong",{parentName:"p"},"intent"),". Intent-based access control (IBAC) bases the authorization model of a server on the set of calls its clients declare they intend to make, granting them access to make declared calls, while blocking undeclared calls."),(0,a.kt)("h2",{id:"intents"},"Intents"),(0,a.kt)("p",null,"An ",(0,a.kt)("strong",{parentName:"p"},"intent"),' is a declaration that service A (the client service) intends to call service B (the server service), often with more granular information about the type of call (e.g. "HTTP" or "Kafka") and other details of the call (e.g. which HTTP resources and methods, or which Kafka topics and operations).'),(0,a.kt)("p",null,"The intent is expressed within a file, specifically a Kubernetes custom resource YAML declaration, that is then created in a specific Kubernetes cluster and namespace via ",(0,a.kt)("inlineCode",{parentName:"p"},"kubectl apply"),". All the intents from a given client should appear in a single client intents YAML file, which then represents the overall intents of that service to be a client of other services."),(0,a.kt)("p",null,"The declared intents applied in this way to a cluster are processed by the ",(0,a.kt)("strong",{parentName:"p"},"Otterize intents operator")," running in the cluster, which -- if configured to enforce intents -- manages Kubernetes network policies and Kafka ACLs according to those intents. When the intents operator is integrated with Otterize Cloud, it also reports those intents to the Cloud, to build an overall model of service-to-service access called the ",(0,a.kt)("strong",{parentName:"p"},"access graph"),"."),(0,a.kt)("p",null,"The declared intents form the basis of IBAC. But to controllably and confidently roll out IBAC to a working cluster, it's important to compare the declared access to the actual access (or attempted access) happening in the cluster. To that end, the ",(0,a.kt)("strong",{parentName:"p"},"Otterize network mapper")," detects attempted access automatically, and generates ",(0,a.kt)("strong",{parentName:"p"},"discovered intents"),": these reflect the intentions of services to call one another based on discovering the actual call attempts themselves. In other words, discovered intents form a network map of services actually calling each other, while declared intents reflect explicit declarations of services to call each other. When the network mapper is integrated with Otterize Cloud, the access graph in the Cloud will includes both discovered and declared intents, and will yield many more insights."),(0,a.kt)("p",null,"Currently, Otterize only supports intents within a cluster (i.e. client and service are within the same cluster), not across clusters."),(0,a.kt)("h2",{id:"services"},"Services"),(0,a.kt)("p",null,"While declared and discovered intents are the edges of the access graph, ",(0,a.kt)("strong",{parentName:"p"},"services"),' are its nodes. A service may be a client of other services, a server to other services, or both. (Note the difference between a "Kubernetes service" which is a specific construct used to make a pod callable by other pods, and an Otterize service that\'s the more general concept, in the sense of a microservice or a workload.)'),(0,a.kt)("p",null,"In Otterize Cloud, services are ",(0,a.kt)("em",{parentName:"p"},"inferred")," from the intents reported to the Cloud by the intents operator and the network mapper: whenever an intent is reported, it carries the information about the client and server of that intent. The intents operator adds more information when the service is identified as a Kafka service (the ",(0,a.kt)("strong",{parentName:"p"},"Kafka server config"),"), and the credentials operator, when integrated, adds yet more information about any ",(0,a.kt)("strong",{parentName:"p"},"certificates")," issued to that service."),(0,a.kt)("p",null,"A service name is unique within a namespace in a cluster, but not in general unique across the cluster or across clusters."),(0,a.kt)("h2",{id:"namespaces-and-environments"},"Namespaces and environments"),(0,a.kt)("p",null,"In a Kubernetes cluster, all services are contained within ",(0,a.kt)("strong",{parentName:"p"},"namespaces"),". Namespaces are used to group services that are similar in some way, and to separate them from other groups of services."),(0,a.kt)("p",null,"When intents are reported to Otterize Cloud, they include information about which namespaces their services are in. If the client and server are in different namespaces, the intent is called a cross-namespace intent. In any case, Otterize Cloud contains representations of all the namespaces reported to it by their association with intents, as well as which services they contain."),(0,a.kt)("p",null,"Because different namespaces may be mapped to different environments, intents may also be cross-environment."),(0,a.kt)("p",null,"In Kubernetes, namespace names must be unique within a cluster."),(0,a.kt)("p",null,"Otterize Cloud adds the concept of ",(0,a.kt)("strong",{parentName:"p"},"environments"),". These have the same meaning usually used in software development: dev, staging, production, etc."),(0,a.kt)("p",null,"You can create and manage as many environments as you need in Otterize Cloud. Just make sure they are meaningful to you. To map them to your cluster, map each namespace to the appropriate environment. All services in a namespace in a cluster are in the same environment. In configuring the integration of the cluster with Otterize Cloud, you will define the ",(0,a.kt)("strong",{parentName:"p"},"default environment")," to which namespaces in that cluster are mapped. Namespaces will be assigned to that environment until you map them to a different environment. If in your situation a cluster is considered to all be within an environment, you won't have to do anything once you've defined the default environment for namespaces in that cluster."),(0,a.kt)("p",null,"Environment names must be unique within an organization."),(0,a.kt)("h2",{id:"integrations"},"Integrations"),(0,a.kt)("p",null,"Otterize Cloud currently supports two types of integrations: ",(0,a.kt)("strong",{parentName:"p"},"Kubernetes integrations")," and ",(0,a.kt)("strong",{parentName:"p"},"generic integrations"),". In the future, many other types of integrations will be added, allowing Otterize Cloud to work seamlessly with all your infrastructures and systems."),(0,a.kt)("p",null,"A Kubernetes integration is used to connect a Kubernetes cluster with Otterize Cloud via any or all of the Otterize operators: the intents operator, the network mapper, and the credentials operator. It contains the credentials needed by the operators running in the Kubernetes cluster to communicate with the Cloud on behalf of that cluster, i.e., it ties together the physical Kubernetes cluster with its representation in Otterize Cloud. The integration also determines the environment to which namespaces in that clusters will be associated by default. The names of Kubernetes-type integrations must be unique within an organization."),(0,a.kt)("p",null,"A generic integration is used to connect generically an external system to Otterize Cloud. It provides that system credentials to access the Otterize API/CLI, in a way that doesn't involve any specific Otterize user. That makes it ideal for building automations on top of the Otterize API. For example, new clusters provisioned for the development team could be automatically connected to Otterize Cloud, or a CI/CD system could automatically look in the access graph for services that would be blocked or intents that were not declared and applied and fail the build. The name of the integration should reflect the way it will be used. The names of generic-type integrations must be unique within an organization."),(0,a.kt)("p",null,"When a Kubernetes cluster is connected to Otterize Cloud, it is represented in the Cloud by an ",(0,a.kt)("strong",{parentName:"p"},"Kubernetes integration")," object. You'll name it when you add a Kubernetes integration in the UI or through the API/CLI."),(0,a.kt)("p",null,"The Otterize operators -- intents operator, network mapper, and/or credentials operator -- running in your cluster will inform the Cloud about the intents, services, and credentials within this cluster, and will also convey their configuration (e.g. shadow or enforcement mode) within this cluster."),(0,a.kt)("p",null,"Note that, while a cluster and its namespaces and services could be in a single environment, and an environment could contain multiple clusters, many other combinations are possible. For example, a cluster could contain namespaces in multiple environments. Or, environments may contain some namespaces in one cluster and other namespaces in another cluster. Use whatever mappings make sense for your situation."))}p.isMDXComponent=!0}}]);