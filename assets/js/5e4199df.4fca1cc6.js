"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1952],{5680:(e,t,n)=>{n.d(t,{xA:()=>p,yg:()=>m});var a=n(6540);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=c(n),g=o,m=u["".concat(l,".").concat(g)]||u[g]||d[g]||r;return n?a.createElement(m,s(s({ref:t},p),{},{components:n})):a.createElement(m,s({ref:t},p))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,s=new Array(r);s[0]=g;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[u]="string"==typeof e?e:o,s[1]=i;for(var c=2;c<r;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},9365:(e,t,n)=>{n.d(t,{A:()=>s});var a=n(6540),o=n(53);const r={tabItem:"tabItem_Ymn6"};function s(e){let{children:t,hidden:n,className:s}=e;return a.createElement("div",{role:"tabpanel",className:(0,o.A)(r.tabItem,s),hidden:n},t)}},1470:(e,t,n)=>{n.d(t,{A:()=>v});var a=n(8168),o=n(6540),r=n(53),s=n(3104),i=n(6347),l=n(7485),c=n(1682),p=n(9466);function u(e){return function(e){return o.Children.map(e,(e=>{if(!e||(0,o.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:o}}=e;return{value:t,label:n,attributes:a,default:o}}))}function d(e){const{values:t,children:n}=e;return(0,o.useMemo)((()=>{const e=t??u(n);return function(e){const t=(0,c.X)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function g(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function m(e){let{queryString:t=!1,groupId:n}=e;const a=(0,i.W6)(),r=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l.aZ)(r),(0,o.useCallback)((e=>{if(!r)return;const t=new URLSearchParams(a.location.search);t.set(r,e),a.replace({...a.location,search:t.toString()})}),[r,a])]}function y(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,r=d(e),[s,i]=(0,o.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!g({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:r}))),[l,c]=m({queryString:n,groupId:a}),[u,y]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,r]=(0,p.Dv)(n);return[a,(0,o.useCallback)((e=>{n&&r.set(e)}),[n,r])]}({groupId:a}),f=(()=>{const e=l??u;return g({value:e,tabValues:r})?e:null})();(0,o.useLayoutEffect)((()=>{f&&i(f)}),[f]);return{selectedValue:s,selectValue:(0,o.useCallback)((e=>{if(!g({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);i(e),c(e),y(e)}),[c,y,r]),tabValues:r}}var f=n(2303);const h={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function b(e){let{className:t,block:n,selectedValue:i,selectValue:l,tabValues:c}=e;const p=[],{blockElementScrollPositionUntilNextRender:u}=(0,s.a_)(),d=e=>{const t=e.currentTarget,n=p.indexOf(t),a=c[n].value;a!==i&&(u(t),l(a))},g=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const n=p.indexOf(e.currentTarget)+1;t=p[n]??p[0];break}case"ArrowLeft":{const n=p.indexOf(e.currentTarget)-1;t=p[n]??p[p.length-1];break}}t?.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":n},t)},c.map((e=>{let{value:t,label:n,attributes:s}=e;return o.createElement("li",(0,a.A)({role:"tab",tabIndex:i===t?0:-1,"aria-selected":i===t,key:t,ref:e=>p.push(e),onKeyDown:g,onClick:d},s,{className:(0,r.A)("tabs__item",h.tabItem,s?.className,{"tabs__item--active":i===t})}),n??t)})))}function w(e){let{lazy:t,children:n,selectedValue:a}=e;const r=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=r.find((e=>e.props.value===a));return e?(0,o.cloneElement)(e,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},r.map(((e,t)=>(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function k(e){const t=y(e);return o.createElement("div",{className:(0,r.A)("tabs-container",h.tabList)},o.createElement(b,(0,a.A)({},e,t)),o.createElement(w,(0,a.A)({},e,t)))}function v(e){const t=(0,f.A)();return o.createElement(k,(0,a.A)({key:String(t)},e))}},4921:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>c,toc:()=>u});var a=n(8168),o=(n(6540),n(5680)),r=n(1470),s=n(9365);const i={sidebar_position:5,title:"Egress NetworkPolicy Automation",image:"/img/quick-tutorials/egress-access-control/social.png"},l=void 0,c={unversionedId:"features/network-mapping-network-policies/tutorials/k8s-egress-access-control-tutorial",id:"features/network-mapping-network-policies/tutorials/k8s-egress-access-control-tutorial",title:"Egress NetworkPolicy Automation",description:"Let\u2019s learn how Otterize automates egress access control with network policies.",source:"@site/docs/features/network-mapping-network-policies/tutorials/k8s-egress-access-control-tutorial.mdx",sourceDirName:"features/network-mapping-network-policies/tutorials",slug:"/features/network-mapping-network-policies/tutorials/k8s-egress-access-control-tutorial",permalink:"/features/network-mapping-network-policies/tutorials/k8s-egress-access-control-tutorial",draft:!1,editUrl:"https://github.com/otterize/docs/edit/main/docs/features/network-mapping-network-policies/tutorials/k8s-egress-access-control-tutorial.mdx",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,title:"Egress NetworkPolicy Automation",image:"/img/quick-tutorials/egress-access-control/social.png"},sidebar:"docSidebar",previous:{title:"AWS EKS network policies with the VPC CNI",permalink:"/features/network-mapping-network-policies/tutorials/aws-eks-cni-mini"},next:{title:"Reference",permalink:"/features/network-mapping-network-policies/reference/"}},p={},u=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Install Otterize on your cluster",id:"install-otterize-on-your-cluster",level:3},{value:"Tutorial",id:"tutorial",level:2},{value:"Deploy the cluster",id:"deploy-the-cluster",level:3},{value:"About Network Policies",id:"about-network-policies",level:3},{value:"Defining our intents",id:"defining-our-intents",level:3},{value:"Applying our intents",id:"applying-our-intents",level:3},{value:"Using DNS and domain names in ClientIntents",id:"using-dns-and-domain-names-in-clientintents",level:3},{value:"Teardown",id:"teardown",level:2}],d={toc:u},g="wrapper";function m(e){let{components:t,...n}=e;return(0,o.yg)(g,(0,a.A)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.yg)("p",null,"Let\u2019s learn how Otterize automates egress access control with network policies."),(0,o.yg)("p",null,"In this tutorial, we will:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Deploy an example cluster consisting of an example frontend for a personal advice application and a server with an external dependency to retrieve wisdom."),(0,o.yg)("li",{parentName:"ul"},"Declare ClientIntents for each workload, including public internet and internal network egress intents."),(0,o.yg)("li",{parentName:"ul"},"See that a network policy was autogenerated to allow just that and block the (undeclared) calls from the other client."),(0,o.yg)("li",{parentName:"ul"},"Revise our intent to use DNS records to tie our network policies to domain names.")),(0,o.yg)("h2",{id:"prerequisites"},"Prerequisites"),(0,o.yg)("h3",{id:"install-otterize-on-your-cluster"},"Install Otterize on your cluster"),(0,o.yg)("p",null,"To deploy Otterize, head over to ",(0,o.yg)("a",{parentName:"p",href:"https://app.otterize.com/"},"Otterize Cloud"),", and to integrate your cluster, navigate to the ",(0,o.yg)("a",{parentName:"p",href:"https://app.otterize.com/integrations"},"Integrations page")," and follow the instructions, but be sure to add the flag below."),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Note:"),"  Egress policy creation is off by default. We must add the following flag when installing Otterize to enable egress policy creation."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-bash"},"--set intentsOperator.operator.enableEgressNetworkPolicyCreation=true\n")),(0,o.yg)("h2",{id:"tutorial"},"Tutorial"),(0,o.yg)("h3",{id:"deploy-the-cluster"},"Deploy the cluster"),(0,o.yg)("p",null,"This will set up the namespace we will use for our tutorial and deploy the cluster containing our front and backend pods. Upon deployment, our cluster will have no network policies in place."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-yaml"},"kubectl create namespace otterize-tutorial-egress-access\nkubectl apply -n otterize-tutorial-egress-access -f ${ABSOLUTE_URL}/code-examples/egress-access-control/all.yaml\n")),(0,o.yg)("h3",{id:"about-network-policies"},"About Network Policies"),(0,o.yg)("p",null,"By default, in Kubernetes, pods are non-isolated. Meaning they accept traffic from any source and can send traffic to any source. When you introduce policies, either ingress or egress pods become isolated. Any connection not explicitly allowed will be rejected. When an ingress policy type is introduced, any traffic that does not match a rule will be rejected. Similarly, when an egress policy type is introduced, any traffic that does not match a rule will not be allowed out of the pod."),(0,o.yg)("p",null,"Stringent policies can be essential in certain sectors, such as healthcare, finance, and government. Implementing egress policies is crucial in minimizing attack surfaces by concealing workloads or restricting the exposure of any compromised workloads. However, challenges may emerge when egress policies are applied to workloads dependent on external communications that were not initially accounted for. These external communications could include DNS, time synchronization, package repositories, logging, telemetry, cloud services, authentication, or other critical external dependencies that, while not directly related to a pod's primary functionality, are vital for its operation."),(0,o.yg)("p",null,"Otterize helps elevate these issues by capturing and mapping the ingress and egress connections used by your pods and then providing suggested policies to maintain your witnessed traffic. You can also enable ",(0,o.yg)("a",{parentName:"p",href:"/reference/shadow-vs-active-enforcement"},"shadow enforcement")," to see which connections would be blocked without committing to active enforcement."),(0,o.yg)("h3",{id:"defining-our-intents"},"Defining our intents"),(0,o.yg)("p",null,"We aim to secure the network in our example cluster by introducing a default deny policy for our entire network and policies for each pod\u2019s appropriate ingress and egress needs."),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Frontend - Needs to retrieve advice from our backend. This will result in an egress policy on our frontend and an ingress policy on our backend."),(0,o.yg)("li",{parentName:"ul"},"Backend - Needs to be able to accept our frontend request and communicate to an external API. This will create an ingress policy for our frontend and an egress policy for the external API.")),(0,o.yg)("p",null,"As previously mentioned, the pods will be non-isolated by default, and everything will work. Check the logs for the frontend workload to see the free advice flowing:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-bash"},"kubectl logs -f -n otterize-tutorial-egress-access deploy/frontend\n")),(0,o.yg)("p",null,"Example log output:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"The answer to all your problems is to:\nThe sun always shines above the clouds.\n\nThe answer to all your problems is to:\nStop procrastinating.\n\nThe answer to all your problems is to:\nDon't feed Mogwais after midnight.\n")),(0,o.yg)("p",null,"View of our non-isolated cluster within Otterize Cloud"),(0,o.yg)("img",{className:"tw-w-128 tw-mb-4",src:"/img/quick-tutorials/egress-access-control/unprotected-network-egress-tutorial.png"}),(0,o.yg)("h3",{id:"applying-our-intents"},"Applying our intents"),(0,o.yg)("p",null,"Given that this is a serious advice application, we want to lock down our pods to ensure no outside inference can occur."),(0,o.yg)("p",null,"To enforce the strict communication rules for our workloads, we will start by applying a default deny policy, ensuring that only explicitly defined connections are allowed. You\u2019ll see that we are allowing UDP on port 53 to support any DNS lookups we need. Without DNS support, our pods could not resolve their cluster names (",(0,o.yg)("em",{parentName:"p"},"frontend"),", ",(0,o.yg)("em",{parentName:"p"},"backend"),") to their internal IP addresses nor resolve the domain names used by our external advise API service."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-bash"},"kubectl apply -n otterize-tutorial-egress-access -f ${ABSOLUTE_URL}/code-examples/egress-access-control/default-deny-policy.yaml\n")),(0,o.yg)("p",null,(0,o.yg)("em",{parentName:"p"},"Default Deny Policy")),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-yaml"},"---\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: default-deny\nspec:\n  podSelector: {}\n  policyTypes:\n  - Egress\n  - Ingress\n  egress:\n      - ports:\n        - protocol: UDP\n          port: 53\n")),(0,o.yg)("p",null,"You can now see in the logs that the pods are isolated from each other and the public internet:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-bash"},"kubectl logs -f -n otterize-tutorial-egress-access deploy/frontend\n")),(0,o.yg)("p",null,"Example log output from ",(0,o.yg)("em",{parentName:"p"},"frontend")," pod:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"Unable to connect to the backend\nUnable to connect to the backend\nUnable to connect to the backend\n")),(0,o.yg)("p",null,"Now that we have secured our broader network, we will apply the following ClientIntents to enable traffic for our workloads."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-bash"},"kubectl apply -n otterize-tutorial-egress-access -f ${ABSOLUTE_URL}/code-examples/egress-access-control/intents.yaml\n")),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: k8s.otterize.com/v2beta1\nkind: ClientIntents\nmetadata:\n  name: frontend\n  namespace:  otterize-tutorial-egress-access\nspec:\n  workload:\n    name: frontend\n    kind: Deployment\n  targets:\n    - service:\n        name: backend\n---\napiVersion: k8s.otterize.com/v2beta1\nkind: ClientIntents\nmetadata:\n  name: backend\n  namespace: otterize-tutorial-egress-access\nspec:\n  workload:\n    name: backend\n    kind: Deployment\n  targets:\n    - internet:\n        ips:\n          - 185.53.57.80 # IP address of our external API\n          # Can also be specified as a CIDR\n          # - 185.53.57.0/24\n")),(0,o.yg)("p",null,"Now, our network and our workloads are only able to open connections to those internal and external resources that are explicitly needed. Below, we can inspect the five different NetworkPolicies generated by Otterize and look at the annotations to see how these policies match their applied pods and designated traffic rules."),(0,o.yg)(r.A,{mdxType:"Tabs"},(0,o.yg)(s.A,{value:"ingress-backend",label:"ingress-backend",default:!0,mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-yaml"},"Name:         access-to-backend-from-otterize-tutorial-egress-access\nNamespace:    otterize-tutorial-egress-access\nCreated on:   2024-02-25 12:20:52 -0800 PST\nLabels:       intents.otterize.com/network-policy=backend-otterize-tutorial-eg-00531a\nAnnotations:  none\nSpec:\n    # Selector specifying pods to which the policy applies. In this case, it targets pod labeled as backend.\n    # Otterize automatically adds these labels, ensuring they persist across deployments and multiple instances.\n    PodSelector:     intents.otterize.com/server=backend-otterize-tutorial-eg-00531a\n  Allowing ingress traffic:\n    # Specifies that the policy allows traffic to any port on the selected pods.\n    To Port: any (traffic allowed to all ports)\n    From:\n      # Specifying the namespace for our pod selector\n      NamespaceSelector: kubernetes.io/metadata.name=otterize-tutorial-egress-access\n      # Further refines the allowed sources of ingress to only those pods with the Otterize managed label\n      PodSelector: intents.otterize.com/access-backend-otterize-tutorial-eg-00531a=true\n  Not affecting egress traffic\n  # Specifies that this policy only applies to incoming traffic to the selected pods.\n  Policy Types: Ingress\n"))),(0,o.yg)(s.A,{value:"ingress-frontend",label:"ingress-frontend",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-yaml"},"Name:         access-to-frontend-from-otterize-tutorial-egress-access\nNamespace:    otterize-tutorial-egress-access\nCreated on:   2024-02-25 12:20:52 -0800 PST\nLabels:       intents.otterize.com/network-policy=frontend-otterize-tutorial-eg-2bb536\nAnnotations:  none\nSpec:\n  # This label identifies the NetworkPolicy as relating to the frontend pod\n  # Otterize automatically adds these labels, ensuring they persist across deployments and multiple instances.\n  PodSelector:     intents.otterize.com/server=frontend-otterize-tutorial-eg-2bb536\n  Allowing ingress traffic:\n    # Specifies that the policy permits traffic to any port on the selected pods\n    To Port: any (traffic allowed to all ports)\n    From:\n      # Specifying the namespace for our pod selector\n      NamespaceSelector: kubernetes.io/metadata.name=otterize-tutorial-egress-access\n      # Further refines the allowed sources of ingress to only those pods with the Otterize managed label\n      PodSelector: intents.otterize.com/access-frontend-otterize-tutorial-eg-2bb536=true\n  Not affecting egress traffic\n  # Specifies that this policy only applies to incoming traffic to the selected pods.\n  Policy Types: Ingress\n"))),(0,o.yg)(s.A,{value:"egress-backend",label:"egress-backend",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-yaml"},'Name:         egress-to-backend.otterize-tutorial-egress-access-from-frontend\nNamespace:    otterize-tutorial-egress-access\nCreated on:   2024-02-25 12:20:52 -0800 PST\nLabels:       intents.otterize.com/egress-network-policy=frontend-otterize-tutorial-eg-2bb536\n              intents.otterize.com/egress-network-policy-target=backend-otterize-tutorial-eg-00531a\nAnnotations:  none\nSpec:\n  # This selector targets the pods to which the policy applies. Here, it specifically targets pods labeled as "client" of the "frontend"\n  # Otterize automatically adds these labels, ensuring they persist across deployments and multiple instances.\n  PodSelector:     intents.otterize.com/client=frontend-otterize-tutorial-eg-2bb536\n  Not affecting ingress traffic\n  Allowing egress traffic:\n    # Specifies that the policy allows egress traffic to any port\n    To Port: any (traffic allowed to all ports)\n    To:\n      # Specifying the namespace for our pod selector\n      NamespaceSelector: kubernetes.io/metadata.name=otterize-tutorial-egress-access\n      # Further refines the allowed sources of egress to only those pods with the Otterize managed label\n      PodSelector: intents.otterize.com/server=backend-otterize-tutorial-eg-00531a\n  # Specifies that this policy only applies to outbound traffic to the selected pods.\n  Policy Types: Egress\n'))),(0,o.yg)(s.A,{value:"egress-frontend",label:"egress-frontend",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-yaml"},'Name:         egress-to-frontend.otterize-tutorial-egress-access-from-backend\nNamespace:    otterize-tutorial-egress-access\nCreated on:   2024-02-25 12:20:52 -0800 PST\nLabels:       intents.otterize.com/egress-network-policy=backend-otterize-tutorial-eg-00531a\n              intents.otterize.com/egress-network-policy-target=frontend-otterize-tutorial-eg-2bb536\nAnnotations:  none\nSpec:\n  # This selector targets the pods to which the policy applies. Here, it specifically targets pods labeled as "client" of the "backend"\n  # Otterize automatically adds these labels, ensuring they persist across deployments and multiple instances.\n  PodSelector:     intents.otterize.com/client=backend-otterize-tutorial-eg-00531a\n  Not affecting ingress traffic\n  Allowing egress traffic:\n    # Specifies that the policy allows egress traffic to any port\n    To Port: any (traffic allowed to all ports)\n    To:\n      # Specifying the namespace for our pod selector\n      NamespaceSelector: kubernetes.io/metadata.name=otterize-tutorial-egress-access\n      # Further refines the allowed sources of egress to only those pods with the Otterize managed label\n      PodSelector: intents.otterize.com/server=frontend-otterize-tutorial-eg-2bb536\n  # Specifies that this policy only applies to outbound traffic to the selected pods.\n  Policy Types: Egress\n\n'))),(0,o.yg)(s.A,{value:"egress-public-backend",label:"egress-public-backend",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-yaml"},'Name:         egress-to-internet-from-backend\nNamespace:    otterize-tutorial-egress-access\nCreated on:   2024-02-25 12:20:52 -0800 PST\nLabels:       intents.otterize.com/egress-internet-network-policy=backend-otterize-tutorial-eg-00531a\nAnnotations:  none\nSpec:\n  # This selector targets the pods to which the policy applies. Here, it specifically targets pods labeled as "client" of the "backend"\n  # Otterize automatically adds these labels, ensuring they persist across deployments and multiple instances.\n  PodSelector:     intents.otterize.com/client=backend-otterize-tutorial-eg-00531a\n  Not affecting ingress traffic\n  Allowing egress traffic:\n    # Specifies that the policy allows egress traffic to any port\n    To Port: any (traffic allowed to all ports)\n    To:\n    # Specifies the IP address range to which the policy allows egress traffic. Here, a /32 CIDR notation indicates a single IP address, suggesting this policy targets the IP address associated with our advise API\n    IPBlock:\n        CIDR: 185.53.57.80/32\n        # The \'Except\' field allows specifying IP addresses within the defined CIDR range that we should exclude, but it is empty in this case.\n        Except:\n  # Specifies that this policy only applies to outbound traffic to the selected pods.\n  Policy Types: Egress\n')))),(0,o.yg)("p",null,"The protected network can be seen on Otterize Cloud:"),(0,o.yg)("img",{className:"tw-w-128 tw-mb-4",src:"/img/quick-tutorials/egress-access-control/cluster-intents-applied.png"}),(0,o.yg)("h3",{id:"using-dns-and-domain-names-in-clientintents"},"Using DNS and domain names in ClientIntents"),(0,o.yg)("p",null,"In the preceding example, a static IP address was employed for the definitions of our intents. Typically, in practical scenarios, a domain name precedes an external service rather than a static IP address. The inherent absence of a direct method to handle NetworkPolicies via domain names presents a considerable challenge in devising policy configurations for services characterized by dynamic IP addresses. However, the capability of ClientIntents to incorporate domain names, DNS records, and static IP addresses offers a flexible solution to this challenge. Below is an enhanced version of a ClientIntent that leverages a domain name."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: k8s.otterize.com/v2beta1\nkind: ClientIntents\nmetadata:\n  name: frontend\n  namespace:  otterize-tutorial-egress-access\nspec:\n  workload:\n    name: frontend\n    kind: Deployment\n  targets:\n    - service:\n        name: backend\n---\napiVersion: k8s.otterize.com/v2beta1\nkind: ClientIntents\nmetadata:\n  name: backend\n  namespace: otterize-tutorial-egress-access\nspec:\n  workload:\n    name: backend\n    kind: Deployment\n  targets:\n    - internet:\n        domains:\n          # Domain name for our advice service\n          - api.adviceslip.com\n")),(0,o.yg)("p",null,"In the above YAML file, we have replaced the IP address with our service\u2019s domain name."),(0,o.yg)("p",null,"Otterize will now track the resolved IP addresses for ",(0,o.yg)("inlineCode",{parentName:"p"},"api.adviceslip.com")," and add them to NetworkPolicies within your clusters."),(0,o.yg)("p",null,"Alternatively, we can use domains prefixed with a wildcard. Otterize will try to match outgoing egress requests\nto wildcard domains by monitoring IPs in DNS responses. So requests to ",(0,o.yg)("inlineCode",{parentName:"p"},"api.adviceslip.com")," will be\npaired with ",(0,o.yg)("inlineCode",{parentName:"p"},"*.adviceslip.com"),".\nSince Otterize cannot resolve ",(0,o.yg)("inlineCode",{parentName:"p"},"*.adviceslip.com"),"'s IP itself, it relies on requests from pods in the cluster by reviewing their DNS response."),(0,o.yg)("p",null,"Let\u2019s deploy the revised intent with the command below:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-bash"},"kubectl apply -n otterize-tutorial-egress-access -f ${ABSOLUTE_URL}/code-examples/egress-access-control/domain-intents.yaml\n")),(0,o.yg)("p",null,"After the updated definition takes effect, with the command below we can view the policy again to find some additions."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-bash"},"kubectl describe clientintents -n otterize-tutorial-egress-access backend --show-events=false\n")),(0,o.yg)("details",null,(0,o.yg)("summary",null,"View Updated ClientIntent Description"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-yaml"},"\nName:         backend\nNamespace:    otterize-tutorial-egress-access\nLabels:       none\nAnnotations:  none\nAPI Version:  k8s.otterize.com/v2beta1\nKind:         ClientIntents\nMetadata:\n  Creation Timestamp:  2024-03-08T18:53:40Z\n  Finalizers:\n    intents.otterize.com/client-intents-finalizer\n  Generation:        2\n  Resource Version:  2122\n  UID:               c93d8cc4-2a8f-404e-b06c-1935176f1dc8\nSpec:\n  targets:\n    Internet:\n      Domains:\n        api.adviceslip.com\n    Service:\n      Name:  frontend\n  Workload:\n    Name:  backend\nStatus:\n  Observed Generation:  2\n  Resolved I Ps:\n    Dns:  api.adviceslip.com\n    Ips:\n      185.53.57.80\n  Up To Date:  true\n"))),(0,o.yg)("p",null,"It is observed that Otterize identifies the IP addresses associated with the domain and incorporates them into a newly established section within the ",(0,o.yg)("inlineCode",{parentName:"p"},"status")," block. This action informs the ",(0,o.yg)("a",{parentName:"p",href:"/reference/intents-operator"},"Intent Operator")," to dynamically adjust the network policies in response to the detection of new IP addresses originating from the specified domain name. For services that utilize dynamic IP addresses, each discovered IP address is systematically added to the network policy. Further details on DNS intents can be explored in the ",(0,o.yg)("a",{parentName:"p",href:"/features/network-mapping-network-policies/reference#clientintents-with-dns"},"Reference"),"."),(0,o.yg)("h2",{id:"teardown"},"Teardown"),(0,o.yg)("p",null,"To remove the deployed examples, run the following:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-bash"},"kubectl delete namespace otterize-tutorial-egress-access\n")))}m.isMDXComponent=!0}}]);