apiVersion: v1
kind: Namespace
metadata:
  name: otterize-tutorial-kafka-mtls
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: client-go
  namespace: otterize-tutorial-kafka-mtls
data:
  client.go: |
    package main

    import (
      "crypto/tls"
      "crypto/x509"
      "fmt"
      "github.com/Shopify/sarama"
      "github.com/sirupsen/logrus"
      "os"
      "time"
    )

    func getTopics() [2]string {
      return [2]string{"mytopic", "transactions"}
    }

    const (
      kafkaAddr  = "kafka.kafka:9092"
      certFile   = "/var/otterize/credentials/cert.pem"
      keyFile    = "/var/otterize/credentials/key.pem"
      rootCAFile = "/var/otterize/credentials/ca.pem"
    )

    func getTLSConfig() (*tls.Config, error) {
      cert, err := tls.LoadX509KeyPair(certFile, keyFile)
      if err != nil {
        return nil, fmt.Errorf("[client] failed loading x509 key pair: %w", err)
      }

      pool := x509.NewCertPool()
      rootCAPEM, err := os.ReadFile(rootCAFile)
      if err != nil {
        return nil, fmt.Errorf("[client] failed loading root CA PEM file: %w ", err)
      }
      pool.AppendCertsFromPEM(rootCAPEM)

      return &tls.Config{
        Certificates: []tls.Certificate{cert},
        RootCAs:      pool,
      }, nil
    }

    func send_messages(producer sarama.SyncProducer, topic string) {
      i := 1
      for {
        msg := fmt.Sprintf("[client] message %d", i)
        _, _, err := producer.SendMessage(&sarama.ProducerMessage{
          Topic:     topic,
          Value:     sarama.StringEncoder(msg),
          Partition: -1,
        })
        if err != nil {
          return
        }
        fmt.Printf("[debug: client] Sent message to [%s] - %s\n", topic, msg)

        time.Sleep(2 * time.Second)
        i++
      }
    }

    func createQueue(topic string, config *sarama.Config, client sarama.Client) error {
      fmt.Println("[client] Creating a producer and a consumer for -", topic)
      config.Producer.Return.Successes = true
      config.Producer.Timeout = 5 * time.Second
      config.Consumer.MaxWaitTime = 5 * time.Second
      config.Producer.Return.Errors = true
      config.Consumer.Return.Errors = true
      producer, err := sarama.NewSyncProducerFromClient(client)
      if err != nil {
        return err
      }

      consumer, err := sarama.NewConsumerFromClient(client)
      if err != nil {
        return err
      }
      fmt.Println("[client] Sending messages")
      go send_messages(producer, topic)

      partConsumer, err := consumer.ConsumePartition(topic, 0, 0)
      if err != nil {
        return err
      }
      for {
        for msg := range partConsumer.Messages() {
          fmt.Printf("[client] Read message from [%s] - %s\n", topic, msg.Value)
        }
      }
    }

    func loop_kafka() error {
      addrs := []string{kafkaAddr}

      config := sarama.NewConfig()
      fmt.Println("[client] Loading mTLS certificates")
      config.Net.TLS.Enable = true
      tlsConfig, err := getTLSConfig()
      if err != nil {
        return err
      }
      config.Net.TLS.Config = tlsConfig
      fmt.Println("[client] Connecting to Kafka")
      config.Net.DialTimeout = 5 * time.Second
      config.Net.ReadTimeout = 5 * time.Second
      config.Net.WriteTimeout = 5 * time.Second
      client, err := sarama.NewClient(addrs, config)
      if err != nil {
        return err
      }
      for _, topic := range getTopics() {
        go createQueue(topic, config, client)
      }
      return nil
    }

    func main() {
      for {
        err := loop_kafka()
        logrus.WithError(err).Println()
        fmt.Println("Loop exited")
        time.Sleep(2 * time.Second)
      }
    }

  go.mod: |
    module main

    go 1.20

    require (
      github.com/Shopify/sarama v1.38.1
      github.com/sirupsen/logrus v1.9.3
    )

    require (
      github.com/davecgh/go-spew v1.1.1 // indirect
      github.com/eapache/go-resiliency v1.3.0 // indirect
      github.com/eapache/go-xerial-snappy v0.0.0-20230111030713-bf00bc1b83b6 // indirect
      github.com/eapache/queue v1.1.0 // indirect
      github.com/golang/snappy v0.0.4 // indirect
      github.com/hashicorp/errwrap v1.0.0 // indirect
      github.com/hashicorp/go-multierror v1.1.1 // indirect
      github.com/hashicorp/go-uuid v1.0.3 // indirect
      github.com/jcmturner/aescts/v2 v2.0.0 // indirect
      github.com/jcmturner/dnsutils/v2 v2.0.0 // indirect
      github.com/jcmturner/gofork v1.7.6 // indirect
      github.com/jcmturner/gokrb5/v8 v8.4.3 // indirect
      github.com/jcmturner/rpc/v2 v2.0.3 // indirect
      github.com/klauspost/compress v1.15.14 // indirect
      github.com/pierrec/lz4/v4 v4.1.17 // indirect
      github.com/rcrowley/go-metrics v0.0.0-20201227073835-cf1acfcdf475 // indirect
      golang.org/x/crypto v0.0.0-20220722155217-630584e8d5aa // indirect
      golang.org/x/net v0.5.0 // indirect
      golang.org/x/sys v0.4.0 // indirect
    )


---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: client
  namespace: otterize-tutorial-kafka-mtls
spec:
  selector:
    matchLabels:
      app: client
  template:
    metadata:
      labels:
        app: client
      annotations:
        credentials-operator.otterize.com/tls-secret-name: client-credentials-secret
    spec:
      containers:
        - name: client
          image: golang
          command: [ "/bin/sh", "-c", "--" ]
          args: [ "while true; do cd /app; cp src/* .; go get main; go run .; sleep infinity; done" ]
          volumeMounts:
            - name: ephemeral
              mountPath: /app
            - mountPath: /app/src
              name: client-go
            - name: otterize-credentials
              mountPath: /var/otterize/credentials
              readOnly: true
      volumes:
        - name: client-go
          configMap:
            name: client-go
        - name: otterize-credentials
          secret:
            secretName: client-credentials-secret
        - name: ephemeral
          emptyDir: { }
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: client-other-go
  namespace: otterize-tutorial-kafka-mtls
data:
  client-other.go: |
    package main

    import (
      "crypto/tls"
      "crypto/x509"
      "fmt"
      "github.com/Shopify/sarama"
      "github.com/sirupsen/logrus"
      "os"
      "time"
    )

    func getTopics() [2]string {
      return [2]string{"mytopic", "transactions"}
    }

    const (
      kafkaAddr  = "kafka.kafka:9092"
      certFile   = "/var/otterize/credentials/cert.pem"
      keyFile    = "/var/otterize/credentials/key.pem"
      rootCAFile = "/var/otterize/credentials/ca.pem"
    )

    func getTLSConfig() (*tls.Config, error) {
      cert, err := tls.LoadX509KeyPair(certFile, keyFile)
      if err != nil {
        return nil, fmt.Errorf("[client-other] failed loading x509 key pair: %w", err)
      }

      pool := x509.NewCertPool()
      rootCAPEM, err := os.ReadFile(rootCAFile)
      if err != nil {
        return nil, fmt.Errorf("[client-other] failed loading root CA PEM file: %w ", err)
      }
      pool.AppendCertsFromPEM(rootCAPEM)

      return &tls.Config{
        Certificates: []tls.Certificate{cert},
        RootCAs:      pool,
      }, nil
    }

    func send_messages(producer sarama.SyncProducer, topic string) {
      i := 1
      for {
        msg := fmt.Sprintf("[client-other] message %d", i)
        _, _, err := producer.SendMessage(&sarama.ProducerMessage{
          Topic:     topic,
          Value:     sarama.StringEncoder(msg),
          Partition: -1,
        })
        if err != nil {
          return
        }
     		fmt.Printf("[debug: client-other] Sent message to [%s] - %s\n", topic, msg)
        time.Sleep(2 * time.Second)
        i++
      }
    }

    func createQueue(topic string, config *sarama.Config, client sarama.Client) error {
      fmt.Println("[client-other] Creating a producer and a consumer for -", topic)
      config.Producer.Return.Successes = true
      config.Producer.Timeout = 5 * time.Second
      config.Consumer.MaxWaitTime = 5 * time.Second
      config.Producer.Return.Errors = true
      config.Consumer.Return.Errors = true
      producer, err := sarama.NewSyncProducerFromClient(client)
      if err != nil {
        return err
      }

      consumer, err := sarama.NewConsumerFromClient(client)
      if err != nil {
        return err
      }
      fmt.Println("[client-other] Sending messages")
      go send_messages(producer, topic)

      partConsumer, err := consumer.ConsumePartition(topic, 0, 0)
      if err != nil {
        return err
      }
      for {
        for msg := range partConsumer.Messages() {
          fmt.Printf("[client-other] Read message from [%s] - %s\n", topic, msg.Value)
        }
      }
    }

    func loop_kafka() error {
      addrs := []string{kafkaAddr}

      config := sarama.NewConfig()
      fmt.Println("[client-other] Loading mTLS certificates")
      config.Net.TLS.Enable = true
      tlsConfig, err := getTLSConfig()
      if err != nil {
        return err
      }
      config.Net.TLS.Config = tlsConfig
      fmt.Println("[client-other] Connecting to Kafka")
      config.Net.DialTimeout = 5 * time.Second
      config.Net.ReadTimeout = 5 * time.Second
      config.Net.WriteTimeout = 5 * time.Second
      client, err := sarama.NewClient(addrs, config)
      if err != nil {
        return err
      }
      for _, topic := range getTopics() {
        go createQueue(topic, config, client)
      }
      return nil
    }

    func main() {
      for {
        err := loop_kafka()
        logrus.WithError(err).Println()
        fmt.Println("Loop exited")
        time.Sleep(2 * time.Second)
      }
    }



  go.mod: |
    module main

    go 1.20

    require (
      github.com/Shopify/sarama v1.38.1
      github.com/sirupsen/logrus v1.9.3
    )

    require (
      github.com/davecgh/go-spew v1.1.1 // indirect
      github.com/eapache/go-resiliency v1.3.0 // indirect
      github.com/eapache/go-xerial-snappy v0.0.0-20230111030713-bf00bc1b83b6 // indirect
      github.com/eapache/queue v1.1.0 // indirect
      github.com/golang/snappy v0.0.4 // indirect
      github.com/hashicorp/errwrap v1.0.0 // indirect
      github.com/hashicorp/go-multierror v1.1.1 // indirect
      github.com/hashicorp/go-uuid v1.0.3 // indirect
      github.com/jcmturner/aescts/v2 v2.0.0 // indirect
      github.com/jcmturner/dnsutils/v2 v2.0.0 // indirect
      github.com/jcmturner/gofork v1.7.6 // indirect
      github.com/jcmturner/gokrb5/v8 v8.4.3 // indirect
      github.com/jcmturner/rpc/v2 v2.0.3 // indirect
      github.com/klauspost/compress v1.15.14 // indirect
      github.com/pierrec/lz4/v4 v4.1.17 // indirect
      github.com/rcrowley/go-metrics v0.0.0-20201227073835-cf1acfcdf475 // indirect
      golang.org/x/crypto v0.0.0-20220722155217-630584e8d5aa // indirect
      golang.org/x/net v0.5.0 // indirect
      golang.org/x/sys v0.4.0 // indirect
    )

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: client-other
  namespace: otterize-tutorial-kafka-mtls
spec:
  selector:
    matchLabels:
      app: client-other
  template:
    metadata:
      labels:
        app: client-other
      annotations:
        credentials-operator.otterize.com/tls-secret-name: client-other-credentials-secret
    spec:
      containers:
        - name: client-other
          image: golang
          command: [ "/bin/sh", "-c", "--" ]
          args: [ "while true; do cd /app; cp src/* .; go get main; go run .; sleep infinity; done" ]
          volumeMounts:
            - name: ephemeral
              mountPath: /app
            - mountPath: /app/src
              name: client-other-go
            - name: otterize-credentials
              mountPath: /var/otterize/credentials
              readOnly: true
      volumes:
        - name: client-other-go
          configMap:
            name: client-other-go
        - name: otterize-credentials
          secret:
            secretName: client-other-credentials-secret
        - name: ephemeral
          emptyDir: { }
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: client-authenticated
  namespace: otterize-tutorial-kafka-mtls
spec:
  selector:
    matchLabels:
      app: client-authenticated
  template:
    metadata:
      labels:
        app: client-authenticated
      annotations:
        credentials-operator.otterize.com/tls-secret-name: client-authenticated-credentials-secret
    spec:
      containers:
        - name: client-authenticated
          image: golang
          command: [ "/bin/sh", "-c", "--" ]
          args: [ "while true; do cd /app; cp src/* .; go get main; go run .; sleep infinity; done" ]
          volumeMounts:
            - name: ephemeral
              mountPath: /app
            - mountPath: /app/src
              name: client-authenticated-go
            - name: otterize-credentials
              mountPath: /var/otterize/credentials
              readOnly: true
      volumes:
        - name: client-authenticated-go
          configMap:
            name: client-authenticated-go
        - name: otterize-credentials
          secret:
            secretName: client-authenticated-credentials-secret
        - name: ephemeral
          emptyDir: { }
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: client-authenticated-go
  namespace: otterize-tutorial-kafka-mtls
data:
  client-authenticated.go: |
    package main

    import (
      "crypto/tls"
      "crypto/x509"
      "fmt"
      "github.com/Shopify/sarama"
      "github.com/sirupsen/logrus"
      "os"
      "time"
    )

    func getTopics() [2]string {
      return [2]string{"mytopic", "transactions"}
    }

    const (
      kafkaAddr  = "kafka.kafka:9092"
      certFile   = "/var/otterize/credentials/cert.pem"
      keyFile    = "/var/otterize/credentials/key.pem"
      rootCAFile = "/var/otterize/credentials/ca.pem"
    )

    func getTLSConfig() (*tls.Config, error) {
      cert, err := tls.LoadX509KeyPair(certFile, keyFile)
      if err != nil {
        return nil, fmt.Errorf("[client-authenticated] failed loading x509 key pair: %w", err)
      }

      pool := x509.NewCertPool()
      rootCAPEM, err := os.ReadFile(rootCAFile)
      if err != nil {
        return nil, fmt.Errorf("[client-authenticated] failed loading root CA PEM file: %w ", err)
      }
      pool.AppendCertsFromPEM(rootCAPEM)

      return &tls.Config{
        Certificates: []tls.Certificate{cert},
        RootCAs:      pool,
      }, nil
    }

    func send_messages(producer sarama.SyncProducer, topic string) {
      i := 1
      for {
        msg := fmt.Sprintf("[client-authenticated] message %d", i)
        _, _, err := producer.SendMessage(&sarama.ProducerMessage{
          Topic:     topic,
          Value:     sarama.StringEncoder(msg),
          Partition: -1,
        })
        if err != nil {
          return
        }
        fmt.Printf("[debug: client-authenticated] Sent message to [%s] - %s\n", topic, msg)
        time.Sleep(2 * time.Second)
        i++
      }
    }

    func createQueue(topic string, config *sarama.Config, client sarama.Client) error {
      fmt.Println("[client-authenticated] Creating a producer and a consumer for -", topic)
      config.Producer.Return.Successes = true
      config.Producer.Timeout = 5 * time.Second
      config.Consumer.MaxWaitTime = 5 * time.Second
      config.Producer.Return.Errors = true
      config.Consumer.Return.Errors = true
      producer, err := sarama.NewSyncProducerFromClient(client)
      if err != nil {
        return err
      }

      consumer, err := sarama.NewConsumerFromClient(client)
      if err != nil {
        return err
      }
      fmt.Println("[client-authenticated] Sending messages")
      go send_messages(producer, topic)

      partConsumer, err := consumer.ConsumePartition(topic, 0, 0)
      if err != nil {
        return err
      }
      for {
        for msg := range partConsumer.Messages() {
          fmt.Printf("[client-authenticated] Read message from [%s] - %s\n", topic, msg.Value)
        }
      }
    }

    func loop_kafka() error {
      addrs := []string{kafkaAddr}

      config := sarama.NewConfig()
      fmt.Println("[client-authenticated] Loading mTLS certificates")
      config.Net.TLS.Enable = true
      tlsConfig, err := getTLSConfig()
      if err != nil {
        return err
      }
      config.Net.TLS.Config = tlsConfig
      fmt.Println("[client-authenticated] Connecting to Kafka")
      config.Net.DialTimeout = 5 * time.Second
      config.Net.ReadTimeout = 5 * time.Second
      config.Net.WriteTimeout = 5 * time.Second
      client, err := sarama.NewClient(addrs, config)
      if err != nil {
        return err
      }
      for _, topic := range getTopics() {
        go createQueue(topic, config, client)
      }
      return nil
    }

    func main() {
      for {
        err := loop_kafka()
        logrus.WithError(err).Println()
        fmt.Println("Loop exited")
        time.Sleep(2 * time.Second)
      }
    }


  go.mod: |
    module main

    go 1.20

    require (
      github.com/Shopify/sarama v1.38.1
      github.com/sirupsen/logrus v1.9.3
    )

    require (
      github.com/davecgh/go-spew v1.1.1 // indirect
      github.com/eapache/go-resiliency v1.3.0 // indirect
      github.com/eapache/go-xerial-snappy v0.0.0-20230111030713-bf00bc1b83b6 // indirect
      github.com/eapache/queue v1.1.0 // indirect
      github.com/golang/snappy v0.0.4 // indirect
      github.com/hashicorp/errwrap v1.0.0 // indirect
      github.com/hashicorp/go-multierror v1.1.1 // indirect
      github.com/hashicorp/go-uuid v1.0.3 // indirect
      github.com/jcmturner/aescts/v2 v2.0.0 // indirect
      github.com/jcmturner/dnsutils/v2 v2.0.0 // indirect
      github.com/jcmturner/gofork v1.7.6 // indirect
      github.com/jcmturner/gokrb5/v8 v8.4.3 // indirect
      github.com/jcmturner/rpc/v2 v2.0.3 // indirect
      github.com/klauspost/compress v1.15.14 // indirect
      github.com/pierrec/lz4/v4 v4.1.17 // indirect
      github.com/rcrowley/go-metrics v0.0.0-20201227073835-cf1acfcdf475 // indirect
      golang.org/x/crypto v0.0.0-20220722155217-630584e8d5aa // indirect
      golang.org/x/net v0.5.0 // indirect
      golang.org/x/sys v0.4.0 // indirect
    )
